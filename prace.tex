%_____________ NOTES_____________%
% V souboru fitthesis.cls jsou přidané balíčky na vkládání kódu do textu: minted apod.
% CHANGES:
% line 1185: \renewcommand{\lstlistingname}{Výpis} %Výpis místo Listing
% číslování zdrojaků v textu: \newtheorem{definition}{Definition}[chapter]


%--- KAPITOLA   Úvod   ------------------------------------------------------------------------------------%
\chapter{Úvod}
\label{chapter:uvod}
Při~automatizovaném testování se může generovat až několik milionů testovacích záznamů za~jeden testovací běh.
Pokud je testování založeno na~parametrizovaných testech, kdy je na~vstupu několik kombinací parametrů, nebo se
používají náhodně generované vstupní parametry, je objem výsledků ještě větší. Výsledky z~testování zpravidla
interpretujeme bezprostředně po~dokončení testů, ale zároveň je žádoucí výsledky uložit, abychom z~nich později mohli získávat statistická data. Zde vyvstává otázka, jaký je vhodný způsob uložení a~zpracování těchto dat. Nejrozšířenější způsob uložení dat určených k~dalšímu zpracování je uložení do~databází. Nejrozšířenějším typem databází jsou dle Google Trends\footnote{\href{https://trends.google.com/trends/explore?date=today\%205-y\&q=sql,nosql,mongodb,mysql,elasticsearch}{https://trends.google.com/trends/explore?date=today\%205-y\&q=sql,nosql,mongodb,mysql,elasticsearch}} a~žebříčku DB-Engines\footnote{\href{https://db-engines.com/en/ranking}{https://db-engines.com/en/ranking}} relační databáze. S~ohledem na~typ dat, která jsou v~databázi uložena, může taková databáze snadno přesáhnout
i~100~GB dat. Čtení takto objemných dat a~zejména následná manipulace, vyhledávání a~třídění může být velmi
náročné. Škálování takovéhoto systému implikuje vynaložení finančních prostředků na~pořízení dalších výpočetních
jednotek nebo na~pořízení výkonnějších zařízení. Dalším možným řešením je optimalizace daného systému, kdy se zvýší efektivita systému za~použití aktuálních výpočetních zdrojů.

Tato práce řeší problém pomalých dotazů nad~relační databází, která uchovává data z~testování ve~firmě Codasip. Cílem práce je na~základě analýzy stávající situace ve~firmě Codasip urychlit provádění aktualizace pohledů a~dotazů nad~testovacími výsledky. Výsledkem této práce je řešení, které naplňuje cíl a~splňuje zadaná netechnická kritéria. Důležitým kritériem je mimo jiné i~snadná integrovatelnost navrženého řešení ve~firemním prostředí firmy Codasip nebo preferované využití volně dostupného a~open--source softwaru\footnote{programové vybavení s~otevřeným zdrojovým kódem}.

V kapitolách~\ref{chapter:testovani_software} a~\ref{chapter:testovaci_nastroje} rozebírám aktuální přístupy k~testování a~nástroje, které se při testování využívají. V~kapitole~\ref{chapter:ukladani_a_vizualizace_dat}
představuji problematiku ukládání a~vizualizace dat a~jaké jsou vlastnosti jednotlivých možností.
Zaměřil jsem se na~výstupy z~testovacího nástroje pytest a~relační databáze, protože tyto nástroje se využívají
ve~firmě Codasip při testování a~zpracování výsledků. Aktuální situaci a~přístup k~problematice ve~firmě Codasip
rozebírám v~kapitole~\ref{chapter:analyza_problemu}. Návrh mého řešení je popsán v~kapitole~\ref{chapter:navrh}, kde popisuji konkrétní kroky vedoucí k~zrychlení zpracování testovacích výsledků. Implementace mého řešení je popsána v~kapitole~\ref{chapter:implementace_reseni}. O~způsobech testování mého řešení a~dosažených výsledcích pojednávám v~kapitole~\ref{chapter:testovani_a_vysledky}. Práce je zakončena kapitolou~\ref{chapter:zaver}.


%--- KAPITOLA   Testování software   -----------------------------------------------------------------------%
\chapter{Testování software}
\label{chapter:testovani_software}
Tato kapitola čerpá informace z~4. vydání publikace \textit{Software Testing}~\cite{SoftwareTesting}. Typický životní cyklus vývoje software (česky programové vybavení) zahrnuje i~část, během které se daný produkt testuje. Pro pochopení, co to je testování, je potřeba znát některé pojmy či definice.
Testování je dle Hamblinga a kolektivu~\cite{SoftwareTesting} chápáno jako proces, který zjišťuje, zda testovaný program, aplikace nebo systém neobsahuje chyby, chová se dle očekávání, splňuje definované požadavky na funkčnost i na nefunkční vlastnosti.
Funkční vlastnosti jsou například správnost výstupu při daných vstupech. Nefunkční vlastnost je například čas (doba trvání), ve kterém těchto výsledků dosáhneme.
Hambling~\cite{SoftwareTesting} zavádí i další jiné dělení testování.
Statické testování je testování, při kterém se nevykonává kód, ale pouze se staticky tento kód hodnotí, posuzuje a kontroluje. Statické testování umožňuje velmi brzy odhalit řadu chyb. Dynamické testování je naopak od statického založeno na provádění kódu programu. Jedná se tedy o testování programu v určitém kontextu. Velké projekty jsou složité systémy a je potřeba provádět testování na více úrovních, které odpovídají určitým úrovním testovaného systému. Více informací o těchto úrovních se lze dočíst v kapitole~\ref{section:urovne_testu}. Při vývoji software je potřeba brát v úvahu míru automatizace testování tak, aby zvolený způsob nebo kombinace vyhovovala potřebám projektu. Více o automatizaci testování v sekci~\ref{section:automatizace_testu_a_testovani}.

\section{Úrovně testů}
\label{section:urovne_testu}
Při testování softwaru se můžeme setkat s~několika úrovněmi testování. Každá úroveň je v něčem důležitá, ale ne všechny projekty vyžadují všechny druhy testů. V následujících podsekcích proberu jednotlivé úrovně testů.

\subsection{Jednotkové testy (testy komponent)}
\label{section:jednotkove_testy}
Na nejnižší úrovni nalezneme tzv. jednotkové testy (anglicky \textit{unit tests}) nebo testy komponent (anglicky \textit{component tests}). Jednotkovými testy se testují jednotlivé části programu -- komponent (proto i název testy komponent). Jednotkové testy můžou testovat funkční nebo nefunkční požadavky. Funkčním požadavkem je například to, že volání určité funkce vrací očekávané výstupní hodnoty. Správná práce s pamětí je příklad nefunkčního požadavku.
Hlavním cílem jednotkových testů je odhalit, jestli jsou nejmenší části programu napsány korektně, prohloubit důvěru v nejmenší části programu. Zároveň se tak jasněji oddělí testování na vyšších úrovních. Vyšší úrovně testů se pak nezabývají nejmenšími detaily, ale soustředí se na složitější problémy.

Mezi problémy, které lze odhalit jednotkovým testováním patří například:
\begin{itemize}
    \item komponenta produkuje chybný výstup,
    \item komponenta nevrací výstup, i když by měla,
    \item kód komponenty je nečitelný (odhalí se při psaní testů),
    \item kód komponenty obsahuje logické chyby.
\end{itemize}

Existují dva přístupy k psaní jednotkových testů. První přístup je takový, kdy se nejprve píše kód komponenty a až následně se píšou jednotkové testy. Při využití druhého přístupu se jako první píšou jednotkové testy a až následně se píše samotný kód komponenty. Druhý způsob je znám jako \textit{Test-driven development (TDD)}, tedy vývoj řízený testy.
Za tento druh testů odpovídá vývojář, který si jednotkovými testy ověřuje, že jeho nově přidaný nebo upravený kus kódu funguje dle očekávání.
Když je na této úrovni vše v pořádku, přichází na řadu testy komponent.

\subsection{Regresní testy}
\label{regresni_testy}
Regresní testy (anglicky \textit{regressison tests}) slouží k zpětnému testování. Kontrolují, jestli se přidáním nové funkce nebo upravením stávající nepoškodila funkčnost celé aplikace.
Regresní testy lze aplikovat na všechny úrovně testování, nejčastěji jsou ale použity na úrovni jednotkových testů.
Množina testů regresního testování se skládá z testů z předchozí iterace vývoje a z nových testů nových přírůstků.

\subsection{Další druhy testů}
\label{subsection:dalsi_druhy_testu}
Další úrovně testování nejsou tolik důležité pro tuto práci, protože tyto úrovně již neprodukují tak velké množství dat a nejsou tedy z tohoto hlediska důležité jako testy jednotkové a regresní. Informace kromě kontrolních testů opět pochází z výše zmíněné publikace~\cite{SoftwareTesting}.

Integrační testy (anglicky \textit{integration tests} slouží k otestování, zda všechny komponenty spolu komunikují korektně a zda celá aplikace běží v pořádku.
Komunikace mezi přihlašovací stránkou, při stisknutí tlačítka \textbf{Login} a back-end aplikací, která autorizuje uživatele.

Kontrolní testy (anglicky \textit{sanity tests}) jsou v publikaci \textit{Software Testing and Continuous Quality Improvement} od William E. Lewise~\cite{SoftwareTestingQualityImprovement} definovány jako testy sloužící k nenáročné, rychlé kontrole funkčnosti. Cílem kontrolních testů je otestovat produkt kompletně, ale rychle. Kontrolní testy jsou často podmnožinou regresních testů a pouští se po integračních testech, tedy již nad stabilně sestaveným produktem.
Po úspěšně zakončeném integračním testování se při menších změnách pouští místo rozsáhlých regresních testů pouze tzv. \textit{sanity check}, tedy kontrolní testy, aby se ověřilo, že chyby odhalené při minulém testování jsou již opraveny a neobjevily se nové.

Systémové testování (anglicky \textit{system testing}) slouží pro otestování hotového produktu v produkčním prostředí. Často tento druh testování provádí nezávislí testeři, kteří se neúčastní vývoje, aby byla zajištěna věrohodná simulace uživatelského použití.
Se systémovým testováním jsou spojeny i akceptační testy (anglicky \textit{user acceptance tests}, které slouží k otestování aplikace koncovými uživateli. Nejedná se tedy již o testery, ale o cílové uživatele. Tento druh testů neslouží již primárně na to, aby odhaloval chyby (kterých by v této fázi vývoje mělo být v produktu co nejméně), ale aby se otestovalo, jak produkt splňuje uživatelská očekávání.


\section{Vývojové přístupy k testování}
Viktor Farcic a Alex Garcia~\cite{TestDrivenJavaDevelopment} zavádějí jiný způsob dělení a to na tzv. \textit{Black-box} a \textit{White-box} testování.
\subsection{Black-box testování}
Černá skříňka (anglicky \textit{black-box}) využívá metody odstínění vývojáře od detailů implementace komponenty a vývojář pracuje pouze s vstupy a výstupy dané komponenty. Testy zpravidla testují korektnost dvojice vstup-výstup. Jedná se tedy o funkční testování.

Výhody, které \textit{black-box} testování nabízí:
\begin{itemize}
    \item odstínění testerů od implementace,
    \item pro testování není nutný přístup ke kódu,
    \item lze takto testovat větší kusy programu,
    \item při změně implementace uvnitř černé skříňky není nutné psát nové nebo upravovat stávající testy.
\end{itemize}
Nevýhody, které \textit{black-box} testování obnáší:
\begin{itemize}
    \item omezené možnosti pokrytí zdrojového kódu,
    \item riziko neodhalení chyby -- kvůli skryté implementaci.
\end{itemize}
Testování pomocí metodiky černé skříňky je nejčastěji realizováno na úrovni jednotkových testů.

\subsection{White-box testování}
Bílá skříňka (anglicky \textit{white-box}) pracuje s přístupem, kdy vývojář zná implementaci dané komponenty a píše testy s ohledem na tuto skutečnost.
V anglicky psané literatuře se můžeme setkat i s názvy \textit{clear-box} nebo \textit{glass-box}. Tyto názvy lépe vystihují podstatu této vývojové metodiky.
Výhody, které \textit{white-box} testování nabízí jsou:
\begin{itemize}
    \item snazší odhalování chyb,
    \item komplexnější pokrytí zdrojového kódu,
    \item možnost optimalizace nebo úpravy zdrojového kódu (v \textit{black-box} testování bylo nemožné, kvůli skrytému kódu).
\end{itemize}
Nevýhody, které \textit{white-box} testování obnáší:
\begin{itemize}
    \item od vývojáře se vyžaduje porozumění kódu,
    \item je nutný přístup ke zdrojovému kódu,
    \item při změně kódu, je zpravidla nutná okamžitá změna v testech.
\end{itemize}
Obě výše zmíněné metodiky lze dobře automatizovat.

\section{Automatizace testů a testování}
\label{section:automatizace_testu_a_testovani}
Brian Hambling a kolektiv~\cite{SoftwareTesting} definují kromě úrovní testů (sekce~\ref{section:urovne_testu}) i způsob, jakým se testy provádí. Způsoby, na které lze testy z tohoto pohledu rozdělit existují podle autorů dva -- manuální a automatické testování. Každý z přístupů má své výhody i nevýhody a specifické požadavky na zavedení, provoz a údržbu.

Manuální testy je možné bez dalších nástrojů a programů. Testy provádí tester a analyzuje výstupy testů. Výhodou manuálního testování je nižší cena (není potřeba pořizovat nebo vyvíjet automatizované testovací nástroje), vyšší flexibilita, protože tester může bezprostředně reagovat na situace a také lze lépe detekovat chyby v reálném uživatelském prostředí. Mezi nevýhody manuálního testování patří přirozeně časová neefektivnost v případě opakujících se testů (například regresní~\ref{regresni_testy}) nebo v případě velkého množství testů. Další z nevýhod je vliv subjektivity a expertízy testera na výsledky testů, špatná reprodukce problémů apod.

Druhým přístupem k testování jsou automatizované testy. Díky automatizovaným testům lze následně zavést automatizaci testování. Tyto dva podobné pojmy s velmi rozdílným významem vysvětluje článek \textit{Test Automation vs. Automated Testing}~\cite{TestAutomationVsAutomatedTesting}. Automatizované testy jsou testy, které vykonávají akce testu automaticky, samostatně pouze pomocí počítače podle předem definovaných pravidel. Při manuálním testování právě tyto akce vykonává tester.
Oproti tomu automatizace testování spočívá v automatizaci samotné správy a řízení testování.

Mezi výhody automatizovaných testů patří efektivní regresní testování nebo testování velkého množství testů. Reprodukce odhalených chyb je u~automatizovaných testů snazší než u~manuálních. Výsledky automatizovaných testů jsou objektivní, nezaujaté a vždy stejně přesné. Nevýhodou automatizovaných testů je například vyšší počáteční finanční a časovou zátěž. Nástroje pro automatizované testování je nutné nejprve zakoupit nebo vyvinout, následně zprovoznit a po celou dobu jejich provozu udržovat. Některé procesy nebo akce, které je potřeba testovat lze testovat automatizovaně s obtížemi nebo dokonce vůbec. Výhodou i nevýhodou zároveň je, že do průběhu automatizovaných testů lze obtížně zasahovat.

V~článku \textit{Best Practices for Test Automation | 2021 Tester’s Checklist}~\cite{BestPracticesForTestAutomation}
společnosti \textit{Katalon} se lze dočíst, že ne všechny testy jsou vhodné pro automatizaci. Mezi vhodné testy
k~automatizaci autoři řadí mimo jiné i~jednotkové a~regresní testy. V~článku se zájemci mohou dočíst i~popis sedmi
kroků vedoucích k nasazení automatizovaného testování.


%--- KAPITOLA   Testovací nástroje a jejich výstupy   --------------------------------------------------------------------%
\chapter{Testovací nástroje a jejich výstupy}
\label{chapter:testovaci_nastroje}
V anglickém jazyce je rozšířený název \textit{framework} (česky aplikační rámec) pro nástroje nebo služby, které
poskytují ucelenou sadu programů, aplikací, příkazů a další řadu služeb, které umožňují určitý typ akce. V~případě
testování se tedy setkáváme s tzv. testovacími frameworky. Tento druh softwaru slouží k~snadnému návrhu,
implementaci a spouštění testů, zpravidla automatizovaných.

V~publikaci~\cite{UnitTestFrameworks} zavádí Paul Hamill celou třídu frameworků pracujících s~jednotkovými testy
jako hlavním druhem testů, kterou autor nazval \textit{xUnit Family}. Do této skupiny patří frameworky jako:
\begin{itemize}
    \item JUnit -- slouží jako vzorová implementace frameworku pro jednotkové testy a více jsem o~tomto frameworku napsal v~sekci~\ref{section:junit},
    \item CppUnit -- jedná se o~implementaci JUnit frameworku pro jazyk C++\footnote{\href{http://www.cplusplus.org/}{http://www.cplusplus.org/}} nebo
    \item utPLSQL -- framework napsaný v~jazyce PL/SQL\footnote{\href{https://www.oracle.com/database/technologies/application-development-pl/sql.html}{https://www.oracle.com/database/technologies/application-development-pl/sql.html}} a určený pro jednotkové testy v~tomto databázovém jazyce firmy Oracle\footnote{\href{https://www.oracle.com/index.html}{https://www.oracle.com/index.html}}.
\end{itemize}
Všechny frameworky z~rodiny xUnit mají společné charakteristiky popsané dříve v~této práci
v~sekci~\ref{section:jednotkove_testy}. Podle Arnaba Roye Chowdhuryho~\cite{Top5PythonTestFrameworks} patří mezi pět
nejlepších frameworků pro jazyk Python frameworky PyUnit a pytest. PyUnit patří do~rodiny xUnit frameworků a má také
jejich společné vlastnosti. Nástroj pytest je testovací framework, který není specializovaný na~určitý druh testů.
V~odlišné rovině pak stojí například framework Selenium\footnote{\href{https://www.selenium.dev/}{https://www.selenium.dev/}}, který slouží pro automatizaci
uživatelských akcí v~prostředí internetových prohlížečů. Pro tuto práci jsou ale nejvíce relevantní právě jednotkové testy a tedy i~frameworky určené pro tento druh testování.
Pro uvedení detailnějších příkladů jsem v~následujících dvou sekcích více rozebral frameworky JUnit (sekce~\ref{section:junit}) a~pytest (sekce~\ref{section:pytest}).

Nejdůležitějším aspektem daného frameworku je pro pro tuto práci výstup, který framework generuje, protože tento výstup slouží jako vstup pro další zpracování a analýzu. Syntax frameworků nebo způsob použití nejsou pro tuto práci stěžejní. V~následujícím textu jsem uvedl krátké ukázky testů a~výstupů, které daný framework vygeneroval.

\section{JUnit}
\label{section:junit}
JUnit\footnote{\href{https://junit.org/junit5/}{https://junit.org/junit5/}} je jednoduchý testovací framework pro psaní a spouštění testů. Jak název napovídá, framework se zaměřuje na~jednotkové testy.
Framework lze využít k~testování například v~jazyce Java, Kotlin nebo Javascript.
Každý test je psán jako samostatná metoda testovací třídy. Každá tato metoda reprezentuje jeden konkrétní scénář
běhu testovaného programu. Ověření správnosti je prováděno pomocí porovnávání očekávaného a reálného výstupu, tedy
tak, jak je pro jednotkové funkční testování obvyklé.
\cite{TestDrivenJavaDevelopment}

Zdrojový kód JUnit (sekce~\ref{code:junit_tests}) testů lze vidět níže. Původní kód~\cite{JUnitExmapleRepository}
z~ukázky jsem zjednodušil pro potřeby této práce. Testy jsou ilustrativního charakteru a~testují pouze operaci sčítání. K parametrizaci testů a dalším akcím jsou použity JUnit anotace\footnote{\href{https://junit.org/junit5/docs/current/user-guide/\#writing-tests-annotations}{https://junit.org/junit5/docs/current/user-guide/\#writing-tests-annotations}}.
Základním formátem výstupu je prostý text. Jak vypadá výstup, který je uživateli zobrazen na standardní výstup je zobrazeno v~kódu~\ref{code:junit_stdout}. JUnit generuje i~XML\footnote{Extensible Markup Language} \textit{report} (česky hlášení), jehož příklad lze vidět v~ukázce~\ref{code:junit_xml_report}, a  HTML\footnote{Hypertext Markup Language} \textit{report}, jehož ukázku můžete vidět na~obrázku~\ref{img:junit_html_report} za~použití nástroje Gradle\footnote{\href{https://gradle.org/}{https://gradle.org/}}. Výstupní soubory sestavení a testování ze~složky \texttt{build} lze použít ke~generování vlastních \textit{reportů} nebo pro~další vlastní zpracování testovacích výsledků.

\lstset{frame=single}
\begin{lstlisting}[language=Java, basicstyle=\footnotesize\ttfamily, label={code:junit_tests}, caption=Zdrojový kód dvou testů napsaných ve~frameworku JUnit. Druhý test je ukázkou parametrizovaného testu.]
    class CalculatorTests {

	@Test
	@DisplayName("1 + 1 = 2")
	void addsTwoNumbers() {
		Calculator calculator = new Calculator();
		assertEquals(2, calculator.add(1, 1), "1 + 1 should equal 2");
	}

	@ParameterizedTest(name = "{0} + {1} = {2}")
	@CsvSource({
			"0,    1,   0",
			"49,  51, 100",
	})
	void add(int first, int second, int expectedResult) {
		Calculator calculator = new Calculator();
		assertEquals(expectedResult, calculator.add(first, second),
			() -> first + " + " + second + " should equal " + expectedResult);
	}
}
\end{lstlisting}
\vspace{0.7em}

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, label={code:junit_stdout}, caption=Příklad standardního výstupu JUnit testu{,} který je tištěn do~konzole. Jedná se o~jednoduchý přehled základních informací o~výsledku testovacího běhu.]
> Task :test
CalculatorTests > 1 + 1 = 2 PASSED
CalculatorTests > 0 + 1 = 1 PASSED
CalculatorTests > 49 + 51 = 100 PASSED
BUILD SUCCESSFUL in 1s
3 actionable tasks: 3 executed
\end{lstlisting}
\vspace{0.7em}

\begin{lstlisting}[language=bash, basicstyle=\scriptsize\ttfamily, label={code:junit_xml_report}, caption=Příklad XML \textit{reportu}{,} který nabízí základní informace o~testovacím běhu a~informace o~výsledku testování.]
<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="com.example.project.CalculatorTests" tests="3" skipped="0" failures="0" errors="0"
           timestamp="2021-04-28T17:49:49" hostname="pc322" time="0.097">
    <properties/>
    <testcase name="1 + 1 = 2" classname="com.example.project.CalculatorTests" time="0.029"/>
    <testcase name="0 + 1 = 1" classname="com.example.project.CalculatorTests" time="0.026"/>
    <testcase name="49 + 51 = 100" classname="com.example.project.CalculatorTests" time="0.002"/>
    <system-out>
        <![CDATA[]]>
    </system-out>
    <system-err>
        <![CDATA[]]>
    </system-err>
</testsuite>
\end{lstlisting}
\vspace{0.7em}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,]{obrazky-figures/junit_report.png}
	\caption{Ukázka HTML \textit{reportu} jako výstupu z~JUnit testovacího běhu. \textit{Report} nabízí souhrnné informace o~testovacím běhu i konkrétních testech. JUnit HTML \textit{report} umožňuje procházet tento \textit{report} podobně jako webovou stránku, a lze tak zobrazit i~podrobný výpis chybového hlášení k~jednotlivých neúspěšným testům.}
	\label{img:junit_html_report}
\end{figure}

\section{pytest}
\label{section:pytest}
Nástroj pytest\footnote{\href{https://docs.pytest.org/}{https://docs.pytest.org/}} je určen pro~testování
programů/skriptů v~jazyce Python. Tento nástroj není specializovaný na~konkrétní druh testů a umožňuje tak psát
jednotkové, integrační i další druhy testů. Testy pro~pytest (dále jen testy) jsou psány jako testovací metody nebo
testovací třídy umístěné v~souborech se specifickým názvem. Je důležité dodržet předepsaný formát jména souboru,
ve~kterém jsou napsané testy, protože pytest využívá prefixu a sufixu jména souboru pro~vyhledávání testů.
V~základním nastavení a bez~dodatečných parametrů pytest vyhledává v~celém adresářovém stromu počínaje kořenovým
adresářem, odkud je pytest spouštěn.

Nástroj pytest pracuje z~velké části automatizovaně, což umožňuje rychlé psaní jednoduchých testů. Pro~složitější a pokročilejší použití se využívají tzv. \textit{hooks} a další pokročilé možnosti nástroje pytest. Více se lze dočíst v~oficiální dokumentaci~\cite{PytestDocumentation}, z~které jsem čerpal informace o~tomto frameworku.
Nástroj pytest nabízí snadné použití výrazů \verb|assert|, které poskytují již v základním nastavení vestavěně podrobné informace o~zachycené aserci a podporu pro~nejčastěji používané výrazy jako např. \textit{volání funkcí, přístupy do polí, aritmetické i objektové porovnaní, binární i unární operátory a další}.

Základním formátem výstupu je prostý text vypsaný do~příkazové řádky. Existují moduly, které umožňují generovat \textit{reporty} ve~formátu XML nebo HTML. Podobně jako u~frameworku JUnit~\ref{section:junit} lze využít těchto souborů pro další zpracování výsledků. Na~příkladě~\ref{code:pytest_tests} lze vidět zdrojový kód testů napsaných ve~frameworku pytest. V~ukázce~\ref{code:pytest_xml_report} pak výstup ve~formátu XML a~na~obrázku~\ref{img:pytest_html_report} \textit{report} ve~formátu HTML.
\begin{lstlisting}[language=Python, basicstyle=\footnotesize\ttfamily, keepspaces=true, label={code:pytest_tests}, caption=Příklad využití frameworku pytest k~testování. Využití tzv.~\textit{fixtures} k~pokročilé parametrizaci testů. Zjednodušeno z~původní verze~\cite{PytestExmapleRepository}.]
import pytest


@pytest.fixture(params=["a", "b"])
def letters_fixture(request):
    yield request.param


@pytest.fixture(params=[1])
def numbers_fixture(request):
    yield request.param


def test_fixtureception(letters_fixture, numbers_fixture):
    coordinate: str = letters_fixture + str(numbers_fixture)
    print('\nRunning test_fixtureception with "{}"'.format(coordinate))
    assert coordinate.startswith('b')
\end{lstlisting}
\vfill

\begin{lstlisting}[language=XML, basicstyle=\footnotesize\ttfamily, keepspaces=true, label={code:pytest_xml_report}, caption=Příklad XML \textit{reportu} testovacích výsledků. V~textu si lze všimnout základních informací o~testovací{,} běhu a~členění výsledků jednotlivých testů.]
<?xml version="1.0" encoding="utf-8"?>
<testsuites>
    <testsuite name="pytest" errors="0" failures="1" skipped="0" tests="2" time="0.079"
               timestamp="2021-04-28T17:57:04.640611" hostname="pc322">
        <testcase classname="tests.09_params-ception_test" name="test_fixtureception[a-1]"
                  time="0.001">
            <failure message="AssertionError: assert False&#10; +  where False = &lt;
                              built-in method startswith of str object at 0x7fa7f7b243b0&gt;
                              ('b')&#10; +    where &lt;built-in method startswith of str
                              object at 0x7fa7f7b243b0&gt; = 'a1'.startswith">
                              letters_fixture = 'a', numbers_fixture = 1

    def test_fixtureception(letters_fixture, numbers_fixture):
        coordinate: str = letters_fixture + str(numbers_fixture)
        print('\nRunning test_fixtureception with "{}"'.format(coordinate))
        &gt;       assert coordinate.startswith('b')
E       AssertionError: assert False
E        +  where False = &lt;built-in method startswith of str object at 0x7fa7f7b243b0&gt;
        ('b')
E        +    where &lt;built-in method startswith of str object at 0x7fa7f7b243b0&gt; =
        'a1'.startswith

tests/09_params-ception_test.py:17: AssertionError</failure>
        </testcase>
        <testcase classname="tests.09_params-ception_test" name="test_fixtureception[b-1]"
                  time="0.001" />
    </testsuite>
</testsuites>
\end{lstlisting}
\vspace{0.7em}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,]{obrazky-figures/pytest_report.png}
	\caption{Ukázka HTML \textit{reportu} jako výstupu z~pytest testovacího běhu. Lze vidět základní informace jako datum a čas, proměnné prostředí, souhrnnou rekapitulaci testovacího běhu a jako poslední podrobné výsledky, ke kterým lze rozbalit podrobnější popis.}
	\label{img:pytest_html_report}
\end{figure}

%-------- KAPITOLA:   Ukládání a vizualizace dat   ---------------------------------------------------------------------%
\chapter{Ukládání a vizualizace dat}
\label{chapter:ukladani_a_vizualizace_dat}
Účelem testování je zjistit, zda v~programu nejsou chyby a jestli se chová dle očekávání. Výsledky časově kratších
testů a~malého rozsahu vyhodnotí vývojář zpravidla ihned po~dokončení testování a~zahájí následné kroky podle
výsledku z~testů. Pokud je testů velké množství, nemusí být vývojář schopen bez dalšího zpracování výsledky
vyhodnotit.
Tato kapitola pojednává zejména o~různých typech databází a~systémech řízení báze dat\footnote{SŘBD = sytém řízení
báze dat, anglicky RMDBS = Relational Database Management System.}, což jsou systémy umožňující vytvoření, úpravy
a~správu databází.

\section{Databáze}
\label{section:databaze}
Databáze je datová struktura, která je organizovaná a~slouží k~modelování určité hierarchie dat nebo k~modelování
organizace dat. Ke~sběru a~uchování těchto dat dnes slouží téměř výhradně specializovaný počítačový program.
Dle Hernandeze~\cite{DatabaseDesignForMereMortlas} lze použití databází rozdělit na~dva typy podle jejich použití.
Prvním typem použití je systém zaměřený na~transakční zpracování dat neboli systém OLTP\footnote{on-line transaction
processing} a~druhým typem je systém zaměřený na~analýzu dat neboli systém OLAP\footnote{on-line analytical processing}.\footnote{OLTP a~OLAP jsou přístupy k~práci s~daty a~databázemi, nikoli přímo typy databází. Pojmy se ale využívají k~definování zaměření databáze. Například pojmem \uv{OLTP databáze} se myslí databáze, která je primárně využívána pro~transakční zpracování požadavků.}

V~paralele k~OLTP a~OLAP lze již samotné databáze korektně rozdělit na~operační a~analytické, kdy operační databáze
jsou využívány při~OLTP a~analytické databáze jsou využívány při~OLAP.
Operační databáze slouží k~uložení a~modifikaci dat, ke~kterým je denní přístup. Data musí být aktuální v~každém
okamžiku a~také se často mění. Využití operačních databází a~OLTP je například v~obchodech, továrnách nebo třeba
v~knihkupectví. Nejčastějšími operacemi v~OLTP databázích jsou \verb|INSERT|, \verb|UPDATE| a~\verb|DELETE|.
Analytické databáze a~OLAP slouží k~uchování historických dat a~k~jejich analýze. Data se zpravidla příliš nemění
a~nejčastěji používanou operací je \verb|SELECT|. Data v~analytické databázi se využívají pro~analytické zpracování,
plánování dalších firemních postupů a~pro~různé prognózy. Uplatnění najde například v~marketingu, chemických
laboratořích nebo v~geologických společnostech.
Data z~operačních databází většinou slouží jako hlavní zdroj dat pro~analytické databáze, avšak návrh a~struktura operačních a~analytických databází jsou velmi odlišené.~\cite{DatabaseDesignForMereMortlas}

Databáze lze také dělit na~\textit{relační} (SQL) a~\textit{nerelační} (NoSQL), jak popisuje John
Hammink~\cite{TypesOfDatabases}. Protože se relační databáze aktivně používají více jak 40 let, tak existuje více
odborníků na~tento druh databází, velké firmy udržují nejpoužívanější SŘBD a~standard jazyka SQL (více o~jazyku SQL v~podsekci~\ref{subsection:sql}) je propracovaný a~dobře udržovaný. Relační databáze jsou vhodné zejména pro~strukturovaná data. Protože testovací systém ve~firmě Codasip generuje právě strukturovaný typ dat, zaměřil jsem se v~následující sekci na~podrobnější popis relačních databází. NoSQL a~další databáze jsem zevrubněji pospal v~sekci~\ref{section:nosql_a_dalsi_databaze}.

\section{Relační databáze}
\label{section:relacni_databaze}
Dle Google Trends\footnote{\href{https://trends.google.com/trends/explore?date=today\%205-y\&q=sql,nosql,mongodb,mysql,elasticsearch}{https://trends.google.com/trends/explore?date=today\%205-y\&q=sql,nosql,mongodb,mysql,elasticsearch}} a~webových stránek DB-Engines\footnote{\href{https://db-engines.com/en/ranking}{https://db-engines.com/en/ranking}} a~Johna Hamminka~\cite{TypesOfDatabases} jsou relační databáze doposud nejrozšířenějším typem databází.
Relační databáze byly poprvé popsány v~roce 1969 a~k~dnešnímu dni se stále jedná o~nejvíce zastoupenou formu
databáze ve světě. Relační databáze jsou založeny na~relačním modelu, jehož autorem je doktor Edgar F. Codd, který
relační model představil oficiálně v~roce 1970 ve~své práci \textit{A Relational Model of Data for Large Shared
Databanks}~\cite{E.F.Codd}. Relační model vychází ze~dvou matematických odvětví, a~to teorie množin a~predikátové
logiky prvního řádu. Slovo \uv{relační} v~názvu relačních databází odkazuje na~matematický termín \uv{relace}.
Tabulka relační databáze představuje tuto~matematickou relaci. Data jsou uložená v~n-ticích -- záznamech (v~řádkově
orientovaných databázích jsou to řádky) složených z~atributů -- hodnot (v~řádkově orientovaných databázích jsou to
hodnoty v~jednotlivých sloupcích). V~následující tabulce~\ref{tab:rel_db_table_example} můžete vidět ukázku jednoduchého uložení dat z~testovacího běhu.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
id & name           & type & passed \\ \hline
1  & test\_addition & unit & 1      \\ \hline
2  & test\_division & unit & 0      \\ \hline
3  & test\_division & unit & 1      \\ \hline
\end{tabular}
\caption{Příklad tabulky v~databázi s~výsledky testů.}
\label{tab:rel_db_table_example}
\end{table}

Více tabulek a~vazby mezi~tabulkami tvoří tzv.~schéma databáze. Jedná se znázornění struktury a~hierarchie dat
v~databázi, více se databázovému schématu věnuji v~podsekci~\ref{subsection:schema_relacni_databaze}.

\subsection{Schéma relační databáze}
\label{subsection:schema_relacni_databaze}
Databázové schéma a~jeho tvorbu  popisuje ve~své knize Keith Gordon~\cite{ModellingBusinessInformationEntityRelationship}.
Databáze reflektuje data a~stav určitého systému. Při~návrhu takovéto databáze se nejprve tvoří tzv. ER\footnote{Entity Relationship} diagram, který modeluje, jaká data mají mezi sebou jaké vztahy. ERD se někdy nazývá
jako schéma. Toto schéma je složeno ze~dvou typů prvků: entitní množiny a~vazebné množiny. Entitní množiny jsou
prakticky tabulky a~vazební množiny pak vazby mezi tabulkami.
Vazební množiny jsou tří typů mocnosti: \uv{\textit{jedna}~ku~\textit{jedné}}, \uv{\textit{jedna}~ku~\textit{n}} a \uv{\textit{m}~ku~\textit{n}}.
U~neurčité mocnosti (\textit{m}~nebo~\textit{n} výše) lze definovat i~minimální hodnotu. O~jakou hodnotu se jedná,
lze určit z~notace mocnosti vazební množiny. Lze použít například číselnou notaci a~psát \uv{0..n} nebo \uv{1..n}.
Návrh databázového schématu je důležitý pro~následnou efektivní a~korektní práci s~databází. Špatný návrh databáze může vést na~její nepoužitelnost.

\subsection{SQL}
\label{subsection:sql}
Jak již bylo zmíněno výše, jazyk SQL je dotazovací jazyk, který je využívaný relačními databázovými systémy.
Dle~knihy \textit{Understanding the New SQL}~\cite{UnderstandingTheNewSQL} je SQL deklarativní programovací jazyk,
kterým lze provádět dotazy nad~danou databází. Pomocí SQL jazyka lze vytvářet, upravovat, mazat a~jinak manipulovat s~celými databázemi, schématy, tabulkami, sloupci nebo~konkrétními záznamy a~jejich atributy. Připravil jsem příklad pro demonstraci jazyka SQL. V~kódu~\ref{code:SQLdemo:create_db} lze vidět příkazy v jazyce SQL pro vytvoření databáze a~k použití této databáze. Vytvoření tabulky a vložení záznamů se nachází v~ukázce~\ref{code:SQLdemo:create_table_insert_revords}. Následné dotazování se nad~tabulkou je provedeno v~kódu~\ref{code:SQLdemo:select}. Jako poslední část příkladu figuruje úprava záznamu a~ověření, že se změny provedly, což lze pozorovat
v~ukázce~\ref{code:SQLdemo:update}. Všechny dílčí kódy ukázky jazyka SQL jsou napsané v~syntaxi jazyka MySQL.
Více se lze o~jazyce SQL dočíst na~webových stránkách organizace ANSI~\cite{ANSISQLWebpage}, která spravuje SQL standard, další příklady SQL syntaxe pak v~příspěvku organizace Free Code Camp~\cite{FreecodecampSQL}.

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:SQLdemo:create_db}, caption=Vytvoření databáze a provedení příkazu pro použití této nově vytvořené databáze.]
-- Vytvoreni databaze.
CREATE DATABASE znamky;

-- Prikaz pro pouziti nove databaze.
USE znamky;
\end{lstlisting}

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:SQLdemo:create_table_insert_revords}, caption=Vytvoření tabulky pro zaznamenávání známek pro předmět Algoritmy a vložení záznamů do této tabulky.]
-- Vytvoreni tabulky pro predmet algoritmy.
CREATE TABLE algoritmy(
    id      bigint auto_increment
        primary key,
    jmeno varchar(15),
    prijmeni varchar(24),
    zadano datetime    null,
    znamka varchar(1)
);

-- Vlozeni zaznamu o znamkach.
INSERT INTO algoritmy (jmeno, prijmeni, zadano, znamka)
VALUES
       ('Petr', 'Solny', '2021-03-28 12:45:57', 'B'),
       ('Antonin', 'Novotny', '2021-03-30 12:05:14', 'D');
\end{lstlisting}

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:SQLdemo:select}, caption=Dotaz nad tabulkou na studenty se známkou C a horší.]
SELECT CONCAT_WS(' ', jmeno, prijmeni) as student, znamka
FROM algoritmy
WHERE znamka >= 'C';
-- Vystup prikazu:
# +---------------+------+
# |student        |znamka|
# +---------------+------+
# |Antonin Novotny|D     |
# +---------------+------+
\end{lstlisting}

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:SQLdemo:update}, caption=Upravení hodnoty atributu \texttt{znamka} u vybraného studenta. Ověření{,} že se právě provedené změny aplikovali.]
-- Uprava zaznamu, odhaleno plagiatorstvi na projektu u studenta Solneho.
UPDATE algoritmy
SET zadano = NOW(), znamka = 'F'
WHERE jmeno = 'Petr' AND prijmeni = 'Solny';

-- Zmeny se provedly.
SELECT CONCAT_WS(' ', jmeno, prijmeni) as student, znamka
FROM algoritmy
WHERE znamka >= 'C';
-- Vystup prikazu:
# +---------------+------+
# |student        |znamka|
# +---------------+------+
# |Petr Solny     |F     |
# |Antonin Novotny|D     |
# +---------------+------+
\end{lstlisting}


\subsection{ACID}
\label{subsection:acid}
Problematiku transakčního zpracování požadavků a~tzv.~\textit{ACID} pravidel definuje dokumentace
Oracle~\cite{OracleTransactions}. ACID je zkratka \textit{Atomicity}, \textit{Consistency}, \textit{Isolation} a~\textit{Durability}. Jednotlivá slova zkratky představují určitá pravidla, která definují práci daného SŘBD s~transakcemi:
\begin{itemize}
    \item Atomicita zaručuje, že buď se provedou všechny transakce nebo se neprovede žádná a~již provedené změny
    budou vráceny nazpět do~původního stavu.
    \item Konzistence zaručuje, že před~provedením a~po~provedení transakce jsou data uložená v~databázi
    v~konzistentním stavu. Například po~provedení převodu finančních prostředků mezi dvěma účty je suma částek
    na~obou účtech stále stejná.
    \item Izolace je vlastnost, která zaručuje, že stav určité transakce v~každý okamžik jejího provádění je
    neviditelný pro ostatní transakce. Například při~převodu peněz ostatní transakce uvidí převáděnou částku vždy
    pouze na~jednom anebo na~druhém účtu, nikdy ne~na~obou zároveň nebo ani~na~jednom z~nich.
    \item Trvalost znamená, že po~dokončení transakce jsou změny trvalé, stálé i~při~vypnutí či~výpadku systému.
\end{itemize}
Tato pravidla definují korespondující vlastnosti, které jsou typické pro~relační databáze. Vlastnosti ACID jsou
nutné pro~korektní transakční zpracování dat typické pro~OLTP typ databází nebo pro~kritické aplikace například z~oblasti bankovnictví. Implementace těchto vlastností je realizována v~rámci daného databázového systému.

\subsection{Partitioning}
\label{subsection:partitioning}
Ačkoli SQL standard nezavádí žádnou správu dat na~fyzické úrovni, protože ANSI SQL definuje SQL jako jazyk, který je
nezávislý na~datových strukturách a~typu úložiště. Databázové \textit{enginy}\footnote{Bez českého ekvivalentu, dle svého principu lze přeložit jako \uv{systém správy uložení dat}.} a~SŘBD ale musí aspekty fyzického uložení,
souborového systému a~samotného hardware řešit. \textit{Partitioning} umožňuje uživateli ovlivnit rozdělení dat na~fyzické
úrovni.
Rozlišujeme dva druhy technologie \textit{partitioning}~--~horizontální a~vertikální. Horizontální \textit{partitioning} umožňuje rozdělit data
podle řádků. Rozdělení se provádí na~základě předem definovaného kritéria, nejčastěji se jedná o~rozdělení
na~základě hodnot určitého sloupce. Různé záznamy/řádky tedy budou fyzicky uloženy do~různých partitions. Druhým
typem technologie \textit{partitioning} je vertikální \textit{partitioning}, při kterém se data dělí podle sloupců. Různé sloupce jsou tedy
fyzicky uloženy v~různých partitions. U~vertikálního verze technologie \textit{partitioning} se pak jedná zpravidla o~přesnou definici
sloupců, zatímco u~horizontálního verze technologie \textit{partitioning} se jednalo o~výraz určující specifické záznamy.

Každý SŘBD má (pokud vůbec) vlastní implementaci technologie \textit{partitioning}. Podle serveru \textit{DB Engines} podporují všechny tři nejpoužívanější SŘBD (Oracle, MySQL a~MS SQL Server) horizontální i~vertikální technologii \textit{partitioning}. Ukázku MySQL technologie \textit{partitioning} lze vidět v~kódu~\ref{code:mysql_partitioning}
\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:mysql_partitioning}, caption=Vytvoření tabulky \texttt{t1} rozdělené do~4 partitions podle hodnoty v~sloupci \texttt{region\_code}. Následuje dotaz nad~tabulkou \texttt{t1}{,} kdy databázový systém může efektivně využít partition p1{,} protože dle~klauzule \texttt{WHERE} se hledají záznamy{,} kde atribut \texttt{region\_code} leží mezi~125 a~130{,} čemuž odpovídá jen a~pouze partition p1.]
CREATE TABLE t1 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( region_code ) (
    PARTITION p0 VALUES LESS THAN (64),
    PARTITION p1 VALUES LESS THAN (128),
    PARTITION p2 VALUES LESS THAN (192),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);

-- Tento dotaz vyuzije partitions a bude prohledavat pouze partition p1.
SELECT fname, lname, region_code, dob
    FROM t1
    WHERE region_code > 125 AND region_code < 130;
\end{lstlisting}

\subsection{Příklady relačních databázových systémů}
\label{subsection:priklady_relacnich_databazovych_systemu}
Podle žebříčku serveru \textit{DB Engines}\footnote{\href{https://db-engines.com/en/ranking}{https://db-engines.com/en/ranking}} mezi první tři nejpoužívanější
databázové systémy patří Oracle, MySQL a~MS~SQL~Server. Každý z~databázových systémů (nejen tyto tři) zpravidla
používá vlastní verzi SQL jazyka, která vychází ze~standardu SQL. Modifikované jazyky SQL bývají podmnožinou ANSI
SQL rozšířenou o~další funkce. Oracle využívá PL/SQL\footnote{\href{https://www.oracle.com/database/technologies/application-development-pl/sql.html}{https://www.oracle.com/database/technologies/application-development-pl/sql.html}}, MySQL implementuje také
svoji verzi a~MS~SQL~Server využívá opět vlastní Transact--SQL\footnote{\href{https://docs.microsoft.com/en-us/sql/t-sql/language-reference?view=sql-server-ver15}{https://docs.microsoft.com/en-us/sql/t-sql/language-reference?view=sql-server-ver15}} (TSQL). Všechny tři zmíněné
relační SŘBD zaručují ACID zpracování transakcí, nabízejí podporu datového formátu XML nebo technologie \textit{partitioning}.
\vfill

\section{NoSQL a~další databáze}
\label{section:nosql_a_dalsi_databaze}
Podle článku \uv{What is NoSQL?}~\cite{NoSQLExplained} je technologie NoSQL popsána jako mladá technologie z~přelomu tisíciletí. Název NoSQL znamená \textit{non SQL} nebo \textit{not only SQL}. Nehledě na~interpretaci názvu, databáze
NoSQL pracují na~odlišném principu než tradiční relační databáze. Databáze NoSQL jsou schopny ukládat relační data,
přestože název NoSQL může evokovat, že tomu tak není.
Hlavní motivací pro~vznik NoSQL databází byl zvyšující se objem dat a~také fakt, že již se jedná pouze o~částečně
strukturovaná nebo zcela nestrukturovaná data, nikoli o~striktně strukturovaná data, jak tomu bylo do~té~doby.
Napomohlo tomu také to, že peněžní cena ukládání dat se výrazně snížila až na~0.01 dolaru za~1 MB v~roce 2000\footnote{v~roce 2017 to je již pouze 0.00003 dolaru za~1 MB} a~bylo proto ekonomicky možné začít pracovat s~velkými objemy nestrukturovaných dat. NoSQL databáze lze klasifikovat do~čtyř hlavních typů.

\subsection{Databáze typu klíč-hodnota}
\label{subsection:key_value_databases}
Struktura dat je jeden velký slovník dvojic klíč-hodnota. Všechna data jsou uložena v~jediném souboru. Typy hodnot
můžou být celé číslo, textový řetězec nebo nejčastěji JSON\footnote{JavaScript Object Notation} struktura.
Dotazování nad~databází typu klíč-hodnota se provádí pomocí referencí na~klíče.
Příkladem databáze typu klíč--hodnota je databáze Redis.
\begin{lstlisting}[language=SQL, basicstyle=\scriptsize\ttfamily, caption=Příklad vložení hodnoty do~Redis databáze pod daným klíčem a~následné získání této hodnoty referencí pomocí klíče.~\cite{RedisIntro}]
> set mykey somevalue
OK
> get mykey
"somevalue"
\end{lstlisting}

\subsection{Databáze založené na~dokumentech}
\label{subsection:document_databases}
Dokumentově orientované databáze ukládají data podobně jako databáze typu klíč-hodnota. Zpravidla se jedná o~JSON
strukturu. Každý z~dokumentů představuje určitou množinou dvojic klíč-hodnota. Dokumentově orientované databáze
umožňují pohodlné horizontální škálování. Stejně jako databáze klíč-hodnota, dokumentově orientované databáze
zpravidla poskytují přímé ORM\footnote{Object Realtion Mapping} pro většinu nejpopulárnějších programovacích jazyků,
tedy k~datům získaným z~databáze lze přistupovat přímo jako k~objektům. Díky metadatům jednotlivých dokumentů jsou
dokumentové databáze schopny dalších optimalizací a~v~určitých případech tedy i~efektivnějších operací oproti
prostým databázím typu klíč-hodnota.~\cite{NoSQLExplained}

\subsection{Wide-column store}
\label{subsection:wide_column_store}
\textit{Wide-column}\footnote{Nemá český překlad, doslovně přeložit lze jako \uv{široký sloupec}.} databáze jsou
podobné tradičním relačním databázím. Data ukládají v~tabulkách a~sloupcích. Sloupce jsou ale u~tohoto typu databází
dynamické. To znamená, že dva řádky v~jedné tabulce můžou mít různý počet sloupců (atributů) nebo různé datové typy
sloupců. Díky tomu jsou \textit{wide-column} databáze v~porovnání s~relačními více flexibilní. Běžným užitím tohoto
typu databází je ukládání IoT (anglicky \textit{Internet of~Things}, česky \textit{Internet věcí}). dat. Příkladem \textit{wide-column
store}/databáze je Apache Cassandra\footnote{\href{https://cassandra.apache.org/}{https://cassandra.apache.org/}} nebo Apache HBase\footnote{\href{https://hbase.apache.org/}{https://hbase.apache.org/}}.

\subsection{Grafové databáze}
\label{subsection:graph_databases}
Grafové databáze jsou specifický druh databází vyvinutý pro~speciální případy užití, kdy je potřeba zkoumat vztahy
mezi určitými entitami. Schéma grafové databáze se skládá z~uzlů a~hran (vychází z~matematické definice grafu). Uzly
představují určité entity a~hrany pak vlastnosti vztahu těchto entit. Typickým případem užití jsou sociální sítě,
algoritmy pro~doporučování obsahu nebo detekce podezřelého (podvodného) chování -- trasování peněžních toků apod.
Příkladem grafové databáze je Neo4j\footnote{\href{https://neo4j.com/}{https://neo4j.com/}} nebo JanusGraph\footnote{\href{https://janusgraph.org/}{https://janusgraph.org/}}.~\cite{NoSQLExplained}

\subsection{NewSQL databáze}
\label{section:newsql_databaze}
NewSQL databáze jsou relační databáze, které zároveň poskytují efektivní horizontální škálování jako NoSQL databáze
a~zároveň garantují vlastnosti ACID (sekce~\ref{subsection:acid}). Mezi zástupce NewSQL databází patří například
CockroachDB\footnote{\href{https://www.cockroachlabs.com/}{https://www.cockroachlabs.com/}}, který nabízí například
partitioning podle geografické lokace a~ochranu před~ztrátou dat na~vysoké úrovni nebo NuoDB\footnote{\href{https://nuodb.com/}{https://nuodb.com/}}, což je distribuovaná SQL databáze zaměřená na~ochranu dat podobně jako CockroachDB.

\section{Vizualizace dat}
\label{section:vizualizace_dat}
Kniha \textit{Hands-On Data Visualization}~\cite{HandsOnDataVisualization} popisuje, jakým způsobem vytvořit
správnou vizualizaci. Pomocí kvalitně vypracované vizualizace dat totiž lze uživateli předat více informací, než by
bylo možné pouhým textem. Slovy lze popsat mnoho, ale vizuální podání informace poskytuje další možnosti, jak
interpretovat data. Správně vizualizovaná data přitahují čtenářovu pozornost k důležitým údajům nebo aspektům dat.
Analýza cílových dat tak může být efektivnější a~rychlejší. Tvorba dobré vizualizace ale není jednoduchý úkol. Jak
píše Jack Dougherty a~Ilya Ilyankou~\cite{HandsOnDataVisualization}, nesprávně vytvořená vizualizace může být
dokonce i~zavádějící.

Při~vizualizování dat je důležité dobré porozumění zkoumané domény i~samotným datům, která jsou analyzována. Pokud se například v~množině zpracovávaných dat nachází extrémy, které se zcela vymykají běžným datům (anglicky
\textit{outliers}, tedy \uv{data, která leží mimo}), je dobré tato data z~naší vizualizace úplně odstranit nebo
použít takové metody, které jsou odolné proti vlivu extrémů. Jako příklad problematiky extrémních dat uvádí autoři
v~\cite{HandsOnDataVisualization} průměr~vs.~medián čísel 1, 2, 3, 4 a~100. Průměr je 22, kdežto medián je 3. Jak je
vidět u~tohoto jednoduchého příkladu, je důležité znát charakter dat, se kterými pracujeme.

Kniha zmiňuje mimo jiné i~pravidla, která by dobrá vizualizace měla splňovat a~rady, čemu se při~vytváření
vizualizace vyhnout a~na~co si dát pozor. Další detailní informace ohledně problematiky vizualizace dat nejsou
pro~potřeby této práce nutné. Uvedu proto dále jen dva příklady vizualizačních nástrojů: Tableau jako zástupce čistě komerčního řešení a~Metabase jako zástupce open--source řešení\footnote{Metabase nabízí mimo open--source verzi svého software i~mimo jiné zpoplatněné \textit{enterprise} řešení.}.

\subsection{Tableau}
\label{subsection:Tableu}
Tableau\footnote{\href{https://www.tableau.com/}{https://www.tableau.com/}} je nástroj pro~komplexní správu, analýzu
a~vizualizaci dat. Tableau je dostupné jako počítačová aplikace, v~prohlížeči, jako aplikace pro~mobilní zařízeni
a~i~jako vestavěná aplikace. Kromě uživateli vytvořených analýz a~pohledů umožňuje Tableau využít i~analýzu
a~interpretaci dat autonomně pomocí umělé inteligence. Pro~provoz Tableau aplikací lze využít cloudových služeb
Tableu, vlastního cloudového řešení anebo čistě lokálního hostingu.
Tableau definuje ve své platformě tři typy uživatelů:
\begin{itemize}
    \item \textit{Creators} -- Tvůrci obsahu, spravují datové zdroje, sestavují analytické pohledy, navrhují
    vizualizace a~nástěnky (dashboardy).
    \item \textit{Explorers} -- Disponují omezeným přístupem k~datům. K~dispozici mají data, která jsou
    předzpracována uživateli \textit{Creators}, nad~těmito daty můžou provádět analýzy, vizualizace apod.
    \item \textit{Viewers} -- Tato úroveň uživatelů může vyhledávat a~zobrazovat dostupné vizualizace a~nástěnky.
    Můžou se také přihlásit k~odběru novinek u~konkrétních vizualizací.
\end{itemize}
Kromě analýzy a~vizualizace dat nabízí Tableau i~dvojici aplikací pro~přípravu a~správu datových zdrojů s~názvem
\textit{Tableau Prep Builder} a~\textit{Tableau Prep Conductor}. Tableau tedy nabízí řešení s~širokým zaměřením. Jedná se ale o~čistě placený nástroj\footnote{Podrobnosti o~zpoplatnění pro~organizace lze nalézt zde: \href{https://www.tableau.com/pricing/teams-orgs}{https://www.tableau.com/pricing/teams-orgs}}.

\subsection{Metabase}
\label{subsection:Metabase}
Metabase\footnote{\href{https://www.metabase.com/}{https://www.metabase.com/}} je nástroj běžící v~prostředí
prohlížeče určený zejména k~vizualizaci dat. Nabízí i~analytické možnosti nebo možnosti správy zdrojových dat.
Metabase podobně jako Tableau nabízí automatickou analýzu a~vizualizaci dat pojmenovanou jako \textit{X-Rays}. Zde
se však jedná o~méně komplexní zpracování dat a~Metabase tak poskytuje vhled spíše na~charakter dat jako počet
unikátních hodnot v~tabulce apod. než komplexní analýzu dat. Metabase lze provozovat buď ve~vlastní režii~--~na~vlastních serverech/zařízeních nebo na~libovolném cloudovém řešení, anebo s~využitím hostingu od~firmy Metabase. Metabase nabízí i~open--source verzi aplikace, která je určená pouze pro~vlastní hosting.


%-------- KAPITOLA:   Analýza problému  -------------------------------------------------------------------%
\chapter{Analýza problému}
\label{chapter:analyza_problemu}
Tato práce řeší problematiku pomalých nebo nedostatečně rychlých databázových dotazů nad~testovacími výsledky.
V~této kapitole řeším celkový systém testování, fyzické charakteristiky, které můžou mít vliv na~rychlost zpracování
výsledků a~celkový průběh procesu od~samotného spuštění testů až po~konečnou vizualizaci výsledků. Zaměřuji se
na~dosavadní datový model, charakteristiku uložených dat a~v~neposlední řadě na~formát a~vlastnosti výstupů
z~testování, protože tyto výstupy jsou vstupem pro~další databázové zpracování.
Číselné a~jiné údaje uváděné v~této kapitole se vztahují k~období psaní této práce.

\section{Analýza současného systému}
\label{section:analyza_systemu}
Celkový systém je znázorněn na~obrázku~\ref{img:system_Codasip}. Jako první bod testovacího systému stojí samotné
testování. Toto testování je řízeno automatizovaně pomocí interního testovacího frameworku a~nástroje Jenkins\footnote{\href{https://www.jenkins.io/}{https://www.jenkins.io/}}. Každý den je provedeno 2,5 až 3,5 milionu testů. Testovací framework obstarává i~plnění databáze základními daty. Celkový počet záznamů zapsaných do~databáze
je pak o~něco větší. Testovací data jsou zpracovávána jednou instancí MySQL. V~rámci databázového systému se základní data dále zpracovávají do~různých pohledů (anglicky \textit{views}), které jsou často agregované nebo
filtrované přes různé atributy. Z~důvodu dlouhého trvání provádění některých pohledů jsou pomalé pohledy uloženy
v~podobě materializovaných pohledů (anglicky \textit{materialized views}). Vizualizace dat z~testování pro~koncové
uživatele\footnote{Koncoví uživatelé systému jsou zejména týmoví vedoucí, kteří sledují, zda vývoj produktů probíhá dle očekávání.} je prováděna pomocí nástroje Metabase\footnote{\href{https://www.metabase.com/}{https://www.metabase.com/}}. Struktura vizualizací v~nástroji
Metabase se skládá z~vizualizačních pohledů zvaných \textit{Questions}. Tyto vizualizace ve~formě tabulek, grafů
apod. jsou komponovány do~nástěnek (anglicky \textit{dashboards}). Z~nástěnek i~vizualizací jsou pak vytvořeny kolekce, v~Metabase zvané \textit{Collections}. Koncoví uživatelé pak využívají vytvořených nástěnek s~vizualizacemi k~monitorování průběhu vývoje produktů firmy Codasip.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{obrazky-figures/system_Codasip.pdf}
	\caption{Diagram celkového systému testování ve~firmě Codasip od~samotných testů až po~vizualizaci.}
	\label{img:system_Codasip}
\end{figure}
V~následujících sekcích proberu jednotlivé části systému podrobněji. Sekce~\ref{section:identifikace_problemu} je věnována shrnutí analýzy a~identifikaci problému, tedy příčiny, proč jsou dotazy nedostatečně rychlé. Řešení problému je pak navrženo v~kapitole~\ref{chapter:navrh}.

\subsection{Testovací framework -- generování dat pro další zpracování}
\label{subsection:Testovaci_framework}
Testovací framework je napsán v~jazyce Python s~intenzivním využitím testovacího frameworku pytest. V~rámci jedné
testovací relace pouští jeden běh nástroje pytest další sadu podřazených relací, jedná se zde o~určité zanoření běhů
tohoto nástroje. Framework je spouštěn pravidelně každý den včetně víkendů a~běží zpravidla přes noc. Cílem je
otestovat denní přírůstky vývoje případně větší změny v~produktech. Přes noc proběhne testování a~následující den by
měli mít vývojáři zpřístupněny výsledky. Některé druhy testů z~důvodu jejich náročnosti ale často končí až v~průběhu
následujícího dne, například během dopoledních hodin. Je žádané, aby i~přesto měli vývojáři výsledky dostupné
jakmile to bude možné. Framework pytest generuje \textit{reporty} ve~formátu HTML a~XML. XML \textit{reporty} podřazených testovacích
relací jsou slučovány a~vkládány do~XML \textit{reportu} nadřazené relace. HTML \textit{reporty} se nijak neupravují. Hlavním výstupem každého testu jsou ale strukturovaná data o~právě proběhnutém testu, která se vkládají do~databáze.

\subsection{Datový model}
\label{subsection:datovy_model}
Referenční ER diagram databáze pro~ukládání testovacích výsledků ve~firmě Codasip je možné vidět
na~obrázku~\ref{img:codasip_referential_data_schema}.
Databáze je plněna strukturovanými daty z~testovacího frameworku. Databázový \textit{engine} je InnoDB. Dle mojí
analýzy vykazují data určité charakteristiky. Většinu objemu dat představuje tabulka \texttt{tests}, konkrétně
98~\%. Tabulku \texttt{tests} pak tvoří z~více jak 99~\% záznamy o~regresních testech překladače. Tabulka
\texttt{sources} uchovává informace o~git\footnote{\href{https://git-scm.com/}{https://git-scm.com/}} repositářích,
větvích (anglicky \textit{branches}) a~revizích, které jsou spjaty s~určitým testovacím během. Kardinalita vazby
na~tabulku \texttt{artifacts} je \textit{n}-\textit{m}. Vazba je implementována pomocí cizího klíče v~tabulce
\texttt{sources} odkazujícího do~tabulky \texttt{artifacts}. Dochází zde proto k~částečné redundanci dat.

Během své analýzy jsem identifikoval, že vazba \texttt{artifacts}-\texttt{sources} není \textit{0..1}-\textit{1}, ale je \textit{m}-\textit{n}. Jednou ze~specializací entitní množiny \texttt{artifacts} je totiž  \texttt{artifacts\_studio}.
Atribut \texttt{artifacts\_studio} reprezentuje sestavení produktu Codasip Studio\textsuperscript{\texttrademark}.  Codasip Studio\textsuperscript{\texttrademark} je sestavováno z~mnoha repositářů. Proto je kardinalita vazby u \texttt{sources} rovna \textit{m}.
Dále pak jedny a~ty samé \uv{zdroje} (repositáře) můžou být zdrojem pro~více testovacích běhů. Například zmiňované Codasip Studio\textsuperscript{\texttrademark} je složeno mimo jiné i~z~repositáře LLVM\footnote{\href{https://llvm.org/}{https://llvm.org/}} překladače. Konkrétní větev a~revize LLVM repositáře může být ale použita ve~více různých verzích Codasip Studia\textsuperscript{\texttrademark}. To znamená, že kardinalita vazby u~\texttt{artifacts} je rovna \textit{n}. Výsledkem je tedy vazební množina \texttt{artifacts}-\texttt{sources} s~kardinalitou \textit{m}-\textit{n}. Reálné schéma lze vidět
na~obrázku~\ref{img:codasip_real_data_schema}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.89\textwidth]{obrazky-figures/codasip_real_data_schema.pdf}
	\caption{Diagram databázového schématu{,} které je použito pro~ukládání a~zpracování dat z~testování se správnými (reálnými) kardinalitami.}
	\label{img:codasip_real_data_schema}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{obrazky-figures/codasip_referential_data_schema.pdf}
	\caption{Diagram databázového schématu{,} které je použito pro~ukládání a~zpracování dat z~testování. Tento diagram byl poskytnut firmou Codasip jako referenční.}
	\label{img:codasip_referential_data_schema}
\end{figure}


\subsection{Zpracování dat}
\label{subsection:zpracovani_dat_v_databazi}
Mezi perzistentní data uložená v~databázi patří i~pohledy a~materializované pohledy. Aktualizaci materializovaných
pohledů obstarávají uložené procedury (anglicky \textit{stored procedures}), které jsou pravidelně spouštěny
plánovanými událostmi. Obnova všech materializovaných pohledů trvá několik hodin. Z~tohoto důvodu jsou data v~těchto
materializovaných pohledech aktuální pouze v~určité časové úseky v~průběhu dne.
Dle mého průzkumu je přístup firmy takový, že se pohledy, které již svojí rychlostí provádění nevyhovují, převádí
na~materializované pohledy. Nicméně těchto materializovaných pohledů stále přibývá a~je tedy nutné vyřešit příčinu, proč je aktualizace pohledů potažmo provádění dotazů pomalé.

Většina sloupců ve~všech tabulkách je indexována indexem typu B--strom~\cite{DatabaseInternals}. Tento index je
vhodný pro~takové atributy, které nabývají co nejvíce různých hodnot. Například primární klíče jsou v~databázovém systému MySQL automaticky indexovány právě tímto typem indexu. Indexem typu B--strom jsou ale indexovány i~atributy jako \texttt{tool} nebo \texttt{kind}, které mají~13, respektive 27~unikátních hodnot. Dle internetových stránek společnosti SAP\footnote{\href{https://wiki.scn.sap.com/wiki/display/EIM/Bitmap+Indexes}{https://wiki.scn.sap.com/wiki/display/EIM/Bitmap+Indexes}} jsou pro~atributy, které mají pouze nízký poměr unikátních hodnot vhodné bitmapové indexy.

Dále jsem zjistil, že některé dotazy jsou napsány nevhodně vůči specifikaci daného dotazu/pohledu. Jednalo se zejména
o~časté použití \texttt{LEFT JOIN}, kdy pohled zobrazoval i~záznamy, které byly pro svůj obsah zcela irelevantní
pro~daný pohled. Nekompletní a~jinak poškozené záznamy určitě do~databáze patří. Jedná se o~důležitou informaci, že
pro~konkrétní test nastala nějaká neočekávaná situace a~chyba buď při samotném testování nebo v~testovacím
frameworku. Pro~analýzu testovacích výsledků, ale nemají takovéto záznamy žádný význam. U~dotazů s~využitím
\texttt{LEFT JOIN} se pak následně v~klauzuli \texttt{WHERE} často filtrovali nalezené záznamy tak, že výsledek
odpovídal využití \texttt{INNER JOIN}.

Časté použití \textit{wildcard} v~klauzulích \texttt{WHERE} na~začátku i~konci vyhledávaného řetězce (např. \texttt{'\%codasip\_urisc\%'}) může značně zpomalovat filtrování podle tohoto atributu. Také si lze všimnout přebytečných spojení tabulek -- pravděpodobně vlivem tvorby nových pohledů kopírováním pohledů stávajících a~jejich následnou úpravou. Zbytečné spojování tabulek nepříznivě ovlivňuje jakýkoli typ dotazu.


\subsection{Vizualizace dat}
\label{subsection:vizualizace_dat}
Pro~účely vizualizace je použitý nástroj Metabase v~open--source verzi. Tato verze, ačkoli je zdarma, nabízí poměrně široké možnosti. Například SQL editor, kde je možné psát SQL dotazy přímo v~rozhraní Metabase. Této možnosti Codasip intenzivně využívá a~jedná se tak o~další vrstvu zpracování dat. SQL editor je použit pro~tvorbu filtrů, které jsou zobrazeny v~grafickém rozhraní. Tyto filtry pak~slouží uživatelům pro dodatečné filtrování nebo řazení. Jak vypadá prostředí Metabase s~uživatelskými filtry je vidět na~obrázku~\ref{img:metabase_ukazka}.
\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\textwidth]{obrazky-figures/metabase_ukazka.png}
	\caption{Dashboard v~prostředí nástroje Metabase{,} který vizualizuje analyzované výsledky regresních testů překladače na~procesorovém jádře uRISC.}
	\label{img:metabase_ukazka}
\end{figure}

\subsection{Parametry hardware a~ostatní charakteristiky systému}
\label{subsection:parametry_hardware}
Kromě výše uvedených oblastí jsem se při~analýze současné situace ve~firmě Codasip zaměřil i~na~vlastnosti hardware strojů, na~kterých běží provoz databáze a~dalších služeb. Motivace k~analýze těchto údajů je fakt, že nízká kapacita operační paměti, pomalé vstupně--výstupní operace na~discích nebo malá propustnost síťového rozhraní můžou být faktory ovlivňující výkonnost celkového systému, zejména pak v~případě využití systému více uživateli současně.

Nejvíce mě zajímalo, na~jaké počítačové konfiguraci se nachází databáze, případně Metabase aplikace. Dle provedené
analýzy se MySQL i~Metabase aplikace nachází na~stejném stroji. Jedná se ale o~virtuální stroj umístěný na~jednom
z~firemních infrastrukturních serverů. Důležitá je tedy nejen konfigurace virtuálního stroje, ale i~fyzického stroje, jehož hardware je virtualizovaný a~sdílený.

Fyzický stroj je založen na~HPE\footnote{\href{https://www.hpe.com/us/en/home.html}{https://www.hpe.com/us/en/home.html}} serveru \textit{ProLiant DL385 Gen10}. Server disponuje 256~GiB operační paměti s~frekvencí 2666~MHz, dvěma
šestnácti--jádrovými procesory AMD EPYC 7281 taktovanými na~2400 MHz s~vyrovnávací pamětí L2 o~velikosti 8~MiB
a~paměti na~úrovni L3 o~velikosti 32~MiB. Tento server je připojen
k~NFS\footnote{\href{https://docs.microsoft.com/en-us/windows-server/storage/nfs/nfs-overview}{https://docs.microsoft.com/en-us/windows-server/storage/nfs/nfs-overview}} SSD poli linkou o~přenosové rychlosti 10~Gbit/s. SSD pole je
založeno na~komplexním řešení firmy NetApp\footnote{\href{https://www.netapp.com/}{https://www.netapp.com/}}, jedná
se o~vysoce výkonné řešení složené z~960~GB SSD disků s~rozhraním SAS 12~GB/s.
Virtuálnímu stroji, na~kterém běží aplikace MySQL a~Metabase je vyhrazeno osm procesorových jader v~100\% výkonu
a~14~GB operační paměti.

\section{Identifikace problému}
\label{section:identifikace_problemu}
Zanalyzoval jsem různé faktory, které mají vliv na~rychlost zpracování databázových dotazů. Nyní lze určit, co je
příčinou pomalých dotazů. Parametry fyzického serveru jsou více než dostačující. Virtuální stroj ovšem disponuje
pouze 14~GB operační paměti. Toto je plně dostačující pro~transakční zpracování testovacích výsledků~--~tedy
pro~vkládání nových dat. Pro~analytické zpracování dat již tato kapacita dostačující být nemusí. Například tabulku
\texttt{tests}, která má 25~GB velikost dat a~45~GB velikost indexu, nelze nahrát do~14~GB paměti a~je nutné
stránkování dat, což přirozeně prodlužuje dobu provádění dotazu.

Transakční funkce databáze pracuje dle očekávání a~v~této oblasti nebyly zaznamenány žádné problémy. Hlavní problém
je v~následném zpracování dat. Tabulka \texttt{tests} je obrovská a~je tvořena z~naprosté většiny záznamy
o~regresních testech překladače. Pohledy jsou diferencovány podle typu procesorových jader (atribut
\texttt{tests.design\_path}) a~podle zaměření testů (atributy \texttt{tests.tool} a~\texttt{tests.kind}). V~každém
z~dotazů, který analyzuje regresní testy překladače musí počítač filtrovat podle atributu \texttt{tool} a~atributu
\texttt{kind} tak, aby vyfiltroval výsledky dle podmínky \texttt{(tests.tool = 'compiler') AND (tests.kind = 'regression')}. Podobně tomu je pak i~u~atributu \texttt{design\_path}, který určuje o~jaký typ procesorového jádra
se jedná. Dotazy, které naopak analyzují něco jiného, než jsou regresní testy překladače, musí prohledat zbytečně
o~několik řádů více záznamů, než je potřeba. Sloupce jsou sice indexovány, ale indexy typu B--strom, kterými jsou sloupce indexovány, nejsou pro tyto účely vhodné.

Co se týká vizualizace, tak zde lze očekávat určité zpomalení, protože se jedná o~další vrstvu zpracování dat
společně s~grafickým zobrazením. Agregace, filtrování a~následné vykreslování grafů, tabulek a~dalších prvků
grafického rozhraní může způsobit sníženou odezvu maximálně několik málo jednotek sekund. Výrazné zpomalení na~úrovni
vizualizace by znamenalo, že je nutné provést optimalizaci na~úrovni databáze.

\section{Současné přístupy}
\label{section:soucasne_pristupy}
Práce řeší velmi komplexní problém složený z~několika částí. Generování testovacích záznamů, jejich následné
zpracování a~konečnou vizualizaci uživatelům. Codasip využívá pro~tyto účely sadu nástrojů, které společně tvoří
určitý celek, ten je podrobněji popsán již výše v~sekci~\ref{section:analyza_systemu}.
Ve~zdrojích, které jsem prohledal, jsem nebyl schopen nalézt vyhovující řešení celkového problému, který by se
podobal problému ve~firmě Codasip. Pokusil jsem se tedy rozložit celý systém na~dílčí části. Pro~dílčí části jsem
ovšem opět v~hledání neuspěl. Autoři článků nebo blogů zpravidla řeší velmi konkrétní problémy nebo diskutují problém
na~příliš jednoduché úrovni. Například ve~firmě \texttt{Qxf2 Services} je zpracování testovacích výsledků z~nástroje
pytest (sekce~\ref{section:pytest}) realizováno pomocí HTML \textit{reportů}. Interakce s~uživateli, kterých se testy týkají, je provedena pomocí zasílání HTML \textit{reportů} cílovým uživatelům elektronickou poštou.~\cite{PytestEmailReporting} Toto je ovšem pro~potřeby firmy Codasip nedostatečná úroveň zpracování výsledků.

Velké úsilí jsem věnoval analýze sady nástrojů \textit{Microsoft Azure DevOps}\footnote{\href{https://docs.microsoft.com/en-us/azure/devops}{https://docs.microsoft.com/en-us/azure/devops}}
(dále jen Azure). Azure tvoří komplexní ekosystém vlastních nástrojů a~řešení, které uživatelům poskytují široké
možnosti pro~automatizaci vývojových procesů, zajištění výpočetního výkonu apod. Aby bylo ale využití Azure výhodné,
bylo by potřeba implementovat co nejvíce částí systému v~prostředí Azure. V~případě firmy Codasip by do prostředí
Azure bylo možné přesunout automatizované testování a~další procesy, které jsou nyní spravovány v~nástroji Jenkins.
Azure dále nabízí podporu zpracování testovacích výsledků z~několika frameworků různých programovacích jazyků.
Pro~Python to je pouze modul \textit{unittest}, a to ne zcela úplně. Microsoft ve~své dokumentaci k~Azure uvádí
příklad sestavení a~testování Python aplikace.~\cite{AzurePythonDemo}

Vizualizace v~Azure těchto testovacích výsledků umožňuje uživateli zobrazit například srovnání různých vývojových
větví v~závislosti na~počtu úspěšných a~neúspěšných testů~--~jak je vidět na~obrázku~\ref{img:azure_tests_by_branches} z~dokumentace k~nástroji Azure\footnote{\href{https://docs.microsoft.com/en-us/azure/devops/pipelines/test/media/review-continuous-test-results-after-build/view-historical-trend.png?view=azure-devops}{https://docs.microsoft.com/en-us/azure/devops/pipelines/test/media/review-continuous-test-results-after-build/view-historical-trend.png?view=azure-devops}}. Azure je schopen automaticky zpracovávat data definovaná základním výstupem z~daného nástroje. Uživatelsky definované výstupy
zpracovávat neumožňuje. Azure nativně nenabízí možnosti uživatelem definovaného zpracování dat, jako by bylo v~případě firmy Codasip například zpracování dat na~základě typu nebo konfigurace jádra. Z~tohoto důvodu by bylo
možné využít Azure DevOps s~výhodou na~automatické testování a~sestavování a~nasazení produktů firmy Codasip. Dále by
Azure mohl poskytnout vhled do~vývojového cyklu na~vyšší úrovni abstrakce, např. pro~technicky zaměřený vyšší
management. Na~pokročilé zpracování dat, jejich analýzu a~vizualizaci ale Azure není, dle mého názoru, vhodně koncipován.

Pro potřeby pokročilého zpracování a~analýzy dat je zapotřebí jiné řešení. Přechod na~Azure technologie by navíc
představoval finanční zátěž, protože služby Azure jsou zpoplatněny\footnote{\href{https://azure.microsoft.com/en-us/pricing/}{https://azure.microsoft.com/en-us/pricing/}}. Protože se mi vyhovující řešení nepodařilo najít, bylo nutné, abych vhodné řešení navrhl sám. Toto řešení je popsáno v~kapitole~\ref{chapter:navrh}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{obrazky-figures/azure_tests_by_branches.png}
	\caption[]{Srovnání úspěšnosti testování na~více vývojových větvích v~prostředí Microsoft Azure.}
	\label{img:azure_tests_by_branches}
\end{figure}

%-------- KAPITOLA:   Návrh řešení   ----------------------------------------------------------------------%
% Návrh je hlavním výstupem MOJÍ práce. Věnovat této kapitole tedy nejvíce úsilí.
% Podle Návrhu by měl být cizí člověk schopen Návrh implementovat.
\chapter{Návrh řešení}
\label{chapter:navrh}
Na~základě analýzy v~kapitole~\ref{chapter:analyza_problemu} v~této kapitole předkládám návrh řešení. Na~úvod bych
rád zmínil požadavky na~řešení, které jsem získal na~základě konzultací s~vývojáři firmy Codasip. Jde o~další
požadavky mimo řešení samotného problému pomalých dotazů, což se implicitně od~mého řešení očekává. Jedná se o~následující:
\begin{itemize}
    \item Řešení by mělo být založeno na~nástrojích, jejichž použití je zdarma i~pro~větší počet uživatelů. Nemusí se jednat přímo o~open--source.
    \item Řešení by mělo využívat takové technologie, které lze hostovat na~vlastních zařízeních uvnitř firemní infrastruktury~--~kvůli správě aplikací, integraci a~ochraně dat.
    \item Integrace řešení by měla být co nejsnadnější, aby bylo možné řešení ihned začít používat.
    \item Jsou preferované takové technologie, jejichž použití nevyžaduje vývojáře se speciální expertízou na~danou technologii.
\end{itemize}

Moje výsledné řešení, při jehož návrhu jsem zohlednil výše uvedené požadavky, se skládá z~několika dílčích částí.
Návrhy jednotlivých dílčích částí postupně rozeberu v~samostatných sekcích. Analogicky k~návrhu jsou napsány i~sekce
v~kapitole~\ref{chapter:implementace_reseni}. Identifikoval jsem, že struktura dat, se kterými systém pracuje, je
vhodná pro~zpracování relačním typem databází. Data jsou řádně strukturovaná na~úrovni výstupu z~testovacího
frameworku. Zároveň ve~firmě již řešení s~využitím relační databáze existuje, což usnadní zavedení nového řešení.
Stávající řešení ale bylo realizováno před několika lety a~nebyly provedeny průběžné změny a~vylepšení tak, aby
systém odpovídal komplexnosti nových dat. Rozhodl jsem se proto ponechat relační typ databáze a~stávající systém
upravit tak, aby reflektoval velikost databáze i~charakter dat, která jsou v~databázi uložena.

Nové technologie typu NewSQL slibují snadné nasazení, použití i správu, maximální výkon apod. Pro firmu Codasip byla
ale prioritou integrovatelnost do~praxe, řešení mělo za~cíl firmě ihned pomoci. Použití nových technologií je tedy
dle mé analýzy pouze lákavým únikem od~reálného problému. Vhodnějším přístupem je použít relační SŘBD a~zaměřit se
na~pokročilou správu takovéhoto systému. Návrh, implementace a~následná správa relačního SŘBD je nelehkým úkolem.
Na základě studia existujících řešení, dostupných technologií a~podrobné analýzy situace ve~firmě Codasip jsem dospěl
k~závěru, že nejlepším řešením problému je použití stávajícího relačního SŘBD MySQL, upravit datový model a~využít
možností, které tento systém nabízí jako je například \texttt{partitioning} nebo uložené procedury a události.

\section{Úprava datového modelu}
\label{section:uprava_datoveho_modelu}
Důležitým prvkem mého řešení je úprava datového modelu. Změny nejsou nikterak složité, ale měly by přinést zrychlení
mnoha pohledů. Diagram upraveného schématu lze vidět na~obrázku~\ref{img:codasip_new_data_schema}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\textwidth]{obrazky-figures/codasip_new_data_schema.pdf}
	\caption{ER diagram upraveného schématu. Lze vidět rozdělení původní tabulky \texttt{tests} na~\texttt{tests\_compiler} a~\texttt{tests\_rest} a~modelace vztahu \texttt{artifacts} a~\texttt{sources} pomocí vazební tabulky \texttt{artifact\_source}}
	\label{img:codasip_new_data_schema}
\end{figure}

Tabulku \texttt{tests} rozdělím na~dvě části. První tabulka nazvaná \texttt{tests\_compiler} bude obsahovat pouze
výsledky regresních testů překladače. Druhá tabulka nazvaná jako \texttt{tests\_rest} bude obsahovat všechny ostatní
záznamy. Tabulka \texttt{tests\_compiler} bude stále tvořit většinu objemu dat, ale důležité je toto logické
rozdělení.
Atributy \texttt{tool} a~\texttt{kind} v~tabulce \texttt{tests\_compiler} můžou působit redundantně, protože všechny
záznamy budou mít stejné hodnoty~--~vždy to budou řetězce \texttt{'compiler'} a~\texttt{'regression'}. Sloupce ale
ponechám, aby bylo možné provádět dotazy nad~celou množinou testovacích záznamů bez nutnosti opětovně vkládat tyto sloupce a data do nich. Spojení tabulek \texttt{tests\_compiler} a~\texttt{tests\_rest} lze snadno provést pomocí operace \texttt{UNION}. Rozdělení dat by šlo řešit i~zavedením \textit{partitions} na~regresní testy překladače
a~zbytek (dále členěný nebo dohromady). Já jsem se rozhodl pro~přímé rozdělení databázového modelu, kvůli snazší
integraci do~systému ve firmě Codasip a hlavně bez nutnosti správy \textit{partitions}.


Dále jsem zavedl vazební tabulku \texttt{artifact\_source} pro modelování vazby tabulek \texttt{artifacts}
a~\texttt{sources}. Tato úprava lze pozorovat ve~spodní části diagramu~\ref{img:codasip_new_data_schema}. Tabulky
\texttt{artifacts} i~\texttt{sources} mají řádově pouze desítky tisíc záznamů, ale
dle~\cite{ModellingBusinessInformationEntityRelationship} se vazby \textit{n}~ku~\textit{m} modelují pomocí vazební
entitní množiny a~implementují právě vazební tabulkou.



\section{Úprava a optimalizace SQL dotazů}
\label{section:uprava_a_optimalizace_SQL_dotazu}
Po důkladné analýze dotazů jsem zjistil, že dotazy obsahují různé množství drobných i~větších nedostatků, které je
třeba vyřešit. Jedná se o~úpravu klauzulí \texttt{JOIN} a~\texttt{WHERE}. Také se pokusím zefektivnit pohledy
s~podmíněnými \texttt{SUM} výrazy v~klauzuli \texttt{SELECT}.

Podle analýzy dat v~databázi a~příkazu \texttt{SELECT DISTINCT name FROM artifacts\_ip;} jsem zjistil, že každý typ procesorového jádra má vždy pouze jeden název. Pro jádro \texttt{codasip\_uvliw} je to tedy vždy pouze řetězec \texttt{codasip\_uvliw} a~nevyskytují se žádné varianty jako by bylo například \texttt{codasip\_uvliw\_reduced} nebo \texttt{codasip\_uvliw\_version\_2} a~podobné. S~tímto zjištěním jsem dále pracoval.
V~referenčních dotazech, jak je vidět na ukázce~\ref{code:query_bad_wildcard}, se ale vyskytuje použití
tzv.~zástupného znaku~--~v~jazyce MySQL znak procenta~\texttt{\%} pro~název jádra. To je zbytečné a~zejména použití
zástupného znaku na~začátku textového řetězce může zpomalovat vykonání dotazu. Databázový systém totiž nemůže
použít prefixového porovnávání řetězců, hledaný řetězec může být přítomen kdekoli v~porovnávaném řetězci. V~případě
zástupného znaku pouze na~konci vyhledávaného řetězce lze použít prefixové porovnávání a~použití zástupného znaku
na~konci vyhledávaného řetězce má tedy menší vliv na~zpomalení rychlosti provedení dotazu.

Další z~úprav bylo sjednocení jmenné konvence atributu \texttt{design\_path} týkající se tabulek \texttt{tests\_compiler}
a~\texttt{tests\_rest}. Po~konzultaci s~vývojáři firmy Codasip jsem zjistil, že vkládání do~databáze se děje na~více
místech zdrojového kódu testovacího frameworku. Vznikají zde dvě varianty názvu testovaného procesorového
jádra~--~verze s~tečkou (např. \texttt{codasip\_urisc.ia}) a~verze s~pomlčkou (např. \texttt{codasip\_urisc-ia}).
Naprostá většina výsledků používá ale pomlčku, proto jsem se rozhodl sjednotit tuto jmennou konvenci na~využití pouze pomlčky.\vfill

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:query_bad_wildcard}, caption=Ukázka chybného použití zástupných znaků \protect\texttt{\%} v~klauzuli \protect\texttt{WHERE} v~referenčním dotazu od~firmy Codasip.]
SELECT
    `artifacts`.`created` AS `date`,
.
.
.
WHERE
	(`tests`.`tool` = 'compiler') AND
	(`tests`.`kind` = 'regression') AND
	(`artifacts_ip`.`name` LIKE '%codasip_uvliw%')
GROUP BY `artifacts`.`created`, `build_id`;
\end{lstlisting}

V~rámci optimalizací SQL dotazů jsem navrhl i~odlišný přístup k~využití sumačních příkazů v~klauzuli \texttt{SELECT}. V~aktuální verzi dotazů (u~těch, u~kterých se sumace vyskytuje v~podobě jak je vidět
na~ukázce~\ref{code:sql_old_sum}) je prováděno vyhodnocení podmínek a~případné přičítání k úhrnné hodnotě pro~každý
záznam, který je databází zpracováván. Já jsem navrhl nejprve provést agregaci přes patřičná data a~to včetně
atributu \texttt{passed}, který udává, zda test byl úspěšný nebo ne. Následně stačí pouze sloučit dílčí výsledky
do~stejné podoby, jako tomu bylo v~původním dotazu.

\lstset{frame=single}
\begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:sql_old_sum}, caption=Kód původního využití příkazu \protect\texttt{SUM} v klauzuli \protect\texttt{SELECT}. Pro~každý záznam jsou vyhodnoceny podmínky a~případně je navýšena úhrnná hodnota.]
SELECT  artifacts.created                                        AS date,
        CONCAT_WS('-', artifacts.version, NULL, artifacts.build) AS build_id,
        SUM((CASE
                WHEN tests.passed = 0 AND tests.design_path = 'codix_berkelium-ia' THEN 1
                ELSE 0 END))                                     AS failed_tests_ia,
        .
        .
        .
        SUM((CASE
                WHEN tests.design_path = 'codix_berkelium-ca' THEN 1
                ELSE 0 END))                                     AS sum_tests_ca
FROM (((tests_compiler AS tests
        INNER JOIN artifacts ON tests.studio_id = artifacts.id)
        INNER JOIN artifacts_studio ON tests.studio_id = artifacts_studio.id)
        INNER JOIN artifacts_ip ON tests.ip_id = artifacts_ip.id)
WHERE DATE(artifacts.created) >= @last_date AND
      artifacts_ip.name = 'codix_berkelium'
GROUP BY artifacts.created, build_id;
\end{lstlisting}

\section{Inteligentní správa materializovaných pohledů}
\label{section:inteligentni_auto_sprava}
Jako hlavní omezení aktuálního řešení vidím mazání záznamů, které se již nebudou měnit a následné opětovné zpracování těchto výsledků. Tento přístup není efektivní a jedná se o jednu z příčin pomalých dotazů. Navrhl jsem proto systém správy dat vložených do materializovaných pohledů, který efektivně pracuje s již uloženými daty a zbytečně nepřepisuje neměnná data.

Tento systém automaticky identifikuje, jaké agregované záznamy již nemůžou být změněny a s těmito záznamy již nijak nemanipuluje. Systém zjistí, jaké je datum záznamů, které můžou být ovlivněny nově příchozími daty. Takovéto záznamy jsou pak aktualizovány stejně jako v původním řešení. Tím, že se místo například půlroční historie zpracovává zpravidla pouze poslední den dochází k výraznému urychlení dotazů a tím se urychluje i vykonání celé aktualizační procedury.

Systém je odolný proti delšímu výpadku aktualizací a~je schopen doplnit i~více chybějících dnů. Celý proces je automatizován a~součástí každé z~procedur, které jsem v~rámci této práce upravoval. Systém nevyžaduje žádné nadstandardní údržby nebo správy. Při vzniku nového materializovaného pohledu a~procedury pro jeho aktualizaci, lze tento systém inteligentní správy dat snadno integrovat.

\section{Partitioning}
\label{section:partitioning}
Pokročilejší práci s~databázovým systémem představuje zavedení \textit{partitions}. Datový model firmy Codasip nabízí
dvě oblasti využití této technologie. První možností je využití \mbox{\textit{partitions}} v~tabulkách ukládajících data.
Z~hlediska objemu připadá v~úvahu tabulka \texttt{tests}. Data jsou již rozdělena na~regresní testy překladače a
zbytek testů. Další často využívaná rovina rozdělení testů je atribut \texttt{design\_path} definující druh procesorového jádra. Rozdělení do~\textit{partitions} lze tedy realizovat na~základě tohoto atributu.

Druhou možností využití jsou materializované pohledy. S~využitím \texttt{partitions} by bylo možné vylepšit systém inteligentní správy dat. Například mazání dat by bylo možné realizovat pomocí \textit{partitions}, pokud by byly pohledy rozděleny do~\textit{partitions} podle kalendářních dat. Případně by se mohly starší~--~nepotřebné výsledky transportovat do~archivního databázového schématu.

\chapter{Implementace řešení}
\label{chapter:implementace_reseni}
% Jak přesně bylo implementováno, to co je v Návrhu.
Řešení jsem na~základě návrhu implementoval v~podobě sady skriptů v~jazyce SQL. Adresářová struktura a~další
podrobnosti týkající se zdrojových souborů těchto skriptů se nachází v~souboru \texttt{README.me} na~přiloženém médiu.
Implementované změny a~SQL skripty lze popsat následovným seznamem:
\begin{itemize}[listparindent=1.55em, parsep=0em]
    \item Sada SQL skriptů pro~transformaci datového modelu. Skripty provedou vytvoření nových tabulek a~jejich naplnění patřičnými daty. Indexy jsou vytvořeny na~vhodné atributy a~vždy typu B--strom, protože jiný typ než B--strom index umožňuje pro MySQL pouze \textit{engine} \textit{Memory}\footnote{\href{https://dev.mysql.com/doc/refman/5.7/en/memory-storage-engine.html}{https://dev.mysql.com/doc/refman/5.7/en/memory-storage-engine.html}}. Velikost databáze tohoto \textit{engine} je limitována velikostí paměti RAM. Pro potřeby systému ve~firmě Codasip proto nelze \textit{engine} \textit{Memory} použít. Použitý \textit{engine} \textit{InnoDB} nabízí pouze indexy typu B--strom.


    \item Sjednocení jmenné konvence atributu \texttt{design\_path} obou tabulek \texttt{tests\_compiler}
    a~\texttt{tests\_rest} jsem implementoval opět jako několik příkazů v~jazyce SQL. Nyní se tedy v~databázi
    nachází záznamy pouze s~pomlčkou (např.~\texttt{codasip\_urisc-ia}).


    \item Optimalizované uložené procedury pro aktualizaci materializovaných pohledů:
    \begin{itemize}
        \item V~rámci úpravy procedur jsem implementoval i~inteligentní správu již zpracovaných dat
        v~materializovaných pohledech. Skripty automaticky zjistí datum nejstaršího záznamu. Následně smažou všechny záznamy z~daného dne a~nahradí je nově zpracovanými daty. V~průběhu dne můžou dobíhat testovací běhy, a~proto je nutné nejmladší záznamy zpracovat znova s~novými daty. Díky této implementaci aktualizace pohledů jsou data vždy aktuální bez~zbytečného opětovného zpracování historických záznamů.

        \item Mimo inteligentní správu zpracovaných dat jsem upravil procedury tak, aby reflektovaly nový datový model. U~regresních testů překladače došlo ke~zjednodušení klauzulí \texttt{WHERE}, kde už není potřeba filtrovat výsledky podle atributů \texttt{tests\_compiler.tool='compiler'}  a~\texttt{tests\_compiler.kind='regression'}.
    \end{itemize}


    \item Odstranil jsem nepotřebné podmínky v~klauzuli \texttt{WHERE} u~několika pohledů, kde byla podmínka
    \texttt{`tests`.`studio\_id` IS NOT NULL} nicméně z~povahy dotazu byly použity pouze spojení tabulek
    \texttt{tests} a~\texttt{artifacts\_studio} typu \texttt{INNER~JOIN} a~nelze tedy dostat z~takového spojení
    prázdnou hodnotu cizího klíče (v~tomto případě \texttt{studio\_id}). Z~tohoto důvodu je takováto podmínka
    zbytečná a~byla odstraněna.


    \item Přepracovaní příkazů \texttt{SUM} v~klauzuli \texttt{SELECT} nevykázalo směrodatné zrychlení provedení dotazu. Tuto změnu jsem tedy neimplementoval více než na~dvou zkušebních, respektive testovacích dotazech. Jak změna vypadá lze vidět v~ukázce~\ref{code:sql_new_sum}.

    \lstset{frame=single}
    \begin{lstlisting}[language=SQL, basicstyle=\footnotesize\ttfamily, label={code:sql_new_sum}, caption=Kód nového přístupu k~využití příkazu \protect\texttt{SUM} v~klauzuli \protect\texttt{SELECT}. Nejprve se provede předvýběr s~agregací potřebných atributů a~následně sloučení dílčích výsledků pro~získaní kompletních dat. Tento přístup ale nepřinesl výraznější zrychlení dotazu a~nebyl proto použit ve~více pohledech. Dále lze vidět použití \texttt{USE~INDEX~(ix\_artifacts\_created)}{,} což je nápověda pro MySQL optimalizátor.]
    SELECT  created                         AS date,
            build_id                        AS build_id,
            SUM((CASE
                    WHEN passed = 0 AND design_path = 'codix_berkelium-ia' THEN count
                    ELSE 0 END))            AS failed_ia,
            .
            .
            .
            SUM((CASE
                    WHEN design_path = 'codix_berkelium-ca' THEN count
                    ELSE 0 END))            AS total_ca
    FROM (SELECT artifacts.created,
                 CONCAT_WS('-', artifacts.version, NULL,
                        artifacts.build)    AS build_id,
                 design_path                AS design_path,
                 passed                     AS passed,
                 count(passed)              AS count
        FROM (((tests_compiler AS tests
                INNER JOIN artifacts USE INDEX (ix_artifacts_created)
                    ON tests.studio_id = artifacts.id)
                INNER JOIN artifacts_studio ON tests.studio_id = artifacts_studio.id)
                INNER JOIN artifacts_ip ON tests.ip_id = artifacts_ip.id)
        WHERE DATE(artifacts.created) >= @last_date
                AND artifacts_ip.name = 'codix_berkelium'
        GROUP BY artifacts.created, build_id, design_path, passed) AS t
    GROUP BY created, build_id;
    \end{lstlisting}


    \item Podmínky některých dotazů neměly dostatečnou selektivitu. Selektivitu lze v~procentech vyjádřit vzorcem:
    $$selektivita = kardinalita/(pocetZaznamu) * 100 .$$ Tato veličina určuje jaké množství záznamů bylo
    vyfiltrováno. Hodnota 100~\% znamená, že navrácen nebyl žádný záznam. Hodnota 0~\% analogicky znamená, že daná
    podmínka neměla žádný vliv a~proces filtrování vrátil všechny záznamy. Je vhodné používat indexy s~co nejvyšší
    selektivitou, protože navracejí nejmenší množství záznamů a~to implikuje rychlejší zpracování dotazu. MySQL
    optimalizátor se o~toto snaží, ale ne vždy je schopen vybrat ten nejlepší index.

    V~pohledech, kde podmínky v~klauzuli \texttt{WHERE} byly méně selektivní než u~jiných pohledů jsem použil konstrukci jazyka SQL \texttt{USE INDEX (<index\_name>)} v~klauzuli \texttt{JOIN}, abych napověděl optimalizátoru MySQL, jaký index použít pro efektivnější filtrování dat.
    Jednalo se o~využití indexu \texttt{ix\_artifacts\_created} pro sloupec \texttt{artifacts.created}, který určuje datum a~čas vytvoření záznamu. Protože nový systém aktualizací materializovaných pohledů obnovuje
    data pouze za~poslední den, je toto využití indexu efektivní v~případech, kdy selektivita ostatních částí
    dotazu není dostatečně vysoká a~zároveň není jiná a~lepší varianta využití jiného indexu tabulky \texttt{artifacts}. Jaké indexy jsou optimalizátorem vybrány a~jaká je míra selektivity dotazu, jsem
    analyzoval pomocí příkazu \texttt{EXPLAIN} a~sloupce \texttt{filtered}, který určuje míru filtrování
    záznamů. Pro ilustraci problematiky uvádím dvě ukázky, kdy bylo využití nápovědy \texttt{USE INDEX} výhodné, a~kdy naopak bylo výhodné využít jiného indexu, respektive bylo výhodné ponechat výběr indexu na~MySQL optimalizátoru.

    V~příkladě~\ref{code:sql_new_sum} lze vidět kód dotazu, který aktualizuje data materializovaného pohledu
    \texttt{mv\_compiler\_regression\_\_urisc\_sum\_by\_build}. V~tomto dotazu je možné vidět v~klauzuli \texttt{INNER~JOIN} použití příkazu \texttt{USE INDEX (<index\_name>)} pro nápovědu použití indexu. Protože záznamů pro jádro \texttt{codix\_berkelium} je v tabulce \texttt{tests\_compiler} velké množství, vyplatí se vyfiltrovat výsledky pomocí data vytvoření,
    protože z charakteru dat a vlastností systému vyplývá, že zpravidla potřebuji pouze výsledky za~jeden den. Optimalizátor tuto informaci nemůže
    nijak získat, proto optimalizátoru napovím formou konstrukce \texttt{USE~INDEX~(ix\_artifacts\_created)}. Kompletní počáteční naplnění všech záznamů trvá s~tímto přístupem déle než u~původního referenčního dotazu. Nicméně s~novým systémem se již materializovaný
    pohled nemaže celý, ale aktualizují se pouze výsledky z~posledního dne. Díky této nápovědě pro použití
    jiného indexu jsem výrazně urychlil aktualizaci některých materializovaných pohledů.
\end{itemize}

V~rámci testování jsem odhalil, že pro výrazné zrychlení je dostatečný můj systém na~správu dat v~materializovaných pohledech, který dle testování funguje spolehlivě. Zavedení \textit{partitions} tedy vnímám jako volitelné řešení. Ačkoli jsem tuto část návrhu neimplementoval, považuji zavedení \textit{parititons} jako jeden z~prvních kroků při budoucí práci na~systému pro zpracování testovacích výsledků ve~firmě Codasip.



%-------- KAPITOLA:   Testování a experimenty   ------------------------------------------------------------%
\chapter{Testování a výsledky}
\label{chapter:testovani_a_vysledky}
% Součástí této kapitoly je i zhodnocení výsledků
Testování svého řešení jsem prováděl na~dvou úrovních. Nejprve bylo potřeba ověřit, že moje úpravy generují
validní výsledky. Ověření, že nové materializované pohledy obsahují správná data jsem prováděl manuálně a~to
tak, že jsem porovnával výsledky referenčních dotazů se svými výsledky. V~některých případech byly očekávané výsledky zcela totožné i ve stejném počtu. U~dotazů, kde jsem měnil klauzule \texttt{LEFT JOIN}
na~\texttt{INNER JOIN} jsem očekával rozdílný počet výsledných záznamů, ale data společných záznamů by měla zůstat stejná.

Druhou rovinou testování bylo ověření, že moje řešení je rychlejší než řešení referenční. Pro účely tohoto
nefunkčního testování (kapitola \ref{chapter:testovani_software} jsem vytvořil speciální uloženou proceduru \texttt{refresh\_wrapper}. Tato
procedura slouží ke~spouštění procedur, které aktualizují jednotlivé materializované pohledy (dále jen
aktualizační procedury). Uložená procedura \texttt{refresh\_wrapper} očekává jeden vstupní argument, a~to název procedury,
která se má spustit. Procedura po~doběhnutí spuštěné aktualizační procedury zaznamená do~tabulky
\texttt{refresh\_event\_log} datum a~čas spuštění aktualizační procedury, údaje o~návratovém kódu a~době trvání
aktualizační procedury a~další informace. Tyto informace lze pak dále analyzovat a~provádět různé statistiky.

Pro vizuální zobrazení dosažených výsledků jsem sestavil vizualizaci v~prostředí aplikace Metabase. Metabase jsem spustil v kontejneru pomocí technologie Docker\footnote{\href{https://www.docker.com/}{https://www.docker.com/}}. Vizualizace, jejíž podobu je možné vidět na~obrázku~\ref{img:mv_visualization}, zobrazuje v~grafu průměrnou dobu trvání vybraných procedur.\footnote{Zobrazeno je šest nejpomalejších, dalších jedenáct pak bylo rychlejších než 7 sekund.} Graf je seřazen podle doby trvání jednotlivých procedur a~obsahuje rozdělení sloupců podle verze dané procedury~--~stará verze první sloupec a~nová verze druhý sloupec.

Dále jsem vytvořil v~aplikaci Metabase dashboard (obrázek~\ref{img:mv_dashboard}), který zobrazuje informace
o~rychlosti provádění procedur, které aktualizují materializované pohledy. Průměrná hodnota je počítána jako
průměr průměrů všech trvání provádění procedur v~tabulce \texttt{refresh\_events\_log}. Doby trvání
nejpomalejších procedur jsou průměr všech běhů dané procedury. Tato vizualizace slouží jako ilustrativní příklad využití aplikace Metabase i~k~další správě dat, nejenom pro vizualizaci testovacích výsledků.\vfill

\section{Zhodnocení výsledků}
\label{section:zhodnoceni_vysledku}
V~této sekci jsem zhodnotil dosažené výsledky mého řešení. Dle dosažených výsledků, které lze vidět na~obrázcích \ref{img:mv_dashboard} a~\ref{img:mv_visualization} je možné tvrdit, že nové řešení přineslo
významné zrychlení v~oblasti aktualizace materializovaných pohledů. Zároveň se mi podařilo splnit požadavky
na~řešení, které využívá nástroje, které jsou zdarma.

Maximální zrychlení se mi podařilo dosáhnout pro materializovaný pohled \newline \texttt{mv\_compiler\_regression\_\_urisc\_sum\_by\_build}, který zobrazuje informace o~regresních testech
překladače pro procesorové jádro uRISC agregované na~základě ID sestavení (verze Codasip Studia\textsuperscript{\texttrademark}). U~tohoto pohledu jsem zrychlil jeho aktualizaci o~více jak 99~\%, protože průměrná doba aktualizace původní verze je 238~sekund a~verze nové 1 sekunda\footnote{Hodnoty menší než jedna sekunda jsou zaokrouhleny nahoru na~jednu sekundu, zrychlení tak může být ještě větší.}
Následuje pohled \texttt{mv\_compiler\_regression\_\_berkelium\_by\_conf} se zrychlením opět více jak 99~\%, pohled \texttt{mv\_compiler\_regression\_\_uvliw\_sum\_by\_build} se zrychlením 93~\%
a~\texttt{mv\_compiler\_regression\_\_uvliw\_by\_branch} s~průměrným zrychlením 95~\%. Celkové průměrné zrychlení napříč všemi pohledy lze spočítat z~hodnot v~\mbox{dashboardu} na obrázku~\ref{img:mv_dashboard} a~toto celkové průměrné zrychlení činí 93\%.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.86\textwidth,]{obrazky-figures/mv_dashboard.png}
	\caption{Dashboard, který zobrazuje průměrné doby trvání procedur, které aktualizují materializované pohledy původního a nového řešení. Dále je zobrazena pro obě řešení nejpomalejší procedura a~její doba trvání.}
	\label{img:mv_dashboard}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.95\textwidth,]{obrazky-figures/mv_vizualization_reduced.png}
	\caption{Průměrná doba vykonávání šesti nejpomalejších aktualizací materializovaných pohledů. První sloupec je původní verze firmy Codasip a~druhý sloupec je nová verze podle mého řešení.}
	\label{img:mv_visualization}
\end{figure}


%-------- KAPITOLA:   Závěr   ------------------------------------------------------------------------------%
\chapter{Závěr}
\label{chapter:zaver}
Práce řeší problém pomalých aktualizací materializovaných pohledů. Problém plyne z potřeby zpracovávat velký objem dat generovaných při testování ve firmě Codasip. Aktuální řešení nebylo dostatečně rychlé.
Nejprve jsem nastudoval teoretické základy týkající se problematiky generování, ukládání, zpracování a~vizualizace dat z~testování software. Poznatky jsem sepsal do~prvních teoretických kapitol. Následně jsem analyzoval a~zhodnotil dostupné nástroje
a~existující řešení.
Protože jsou požadavky firmy Codasip specifické a~nepodařilo se mi najít existující
řešení, které by bylo dostatečně vyhovující, navrhl jsem vlastní nové řešení.

Moje řešení se zaměřuje na~úpravu datového modelu podle vlastností obsažených dat. Nový datový model je lépe
strukturovaný s~ohledem na~následné zpracování dat. Dále jsem navrhl efektivní správu již zpracovaných dat
a~automatické doplňování pouze chybějících dat. Další částí návrhu byla optimalizace samotných dotazů.
Navržené řešení jsem úspěšně implementoval a~otestoval pomocí reálných referenčních dat, ke~kterým mi dala firma Codasip přístup.

Za~stěžejní části této práce, a~oblasti, na~které je dle mého názoru potřeba se zaměřit při řešení podobného
problému, považuji detailní analýzu konkrétní situace, systému a dat, se kterými daný systém pracuje. Dále je
důležité znát možnosti, silné stránky a~omezení konkrétních použitých technologií. S~komplexním pochopením
technologií i~dat pak lze úspěšně navrhnout a~implementovat kvalitní řešení. Jsem názoru, že toto se mi v~mé
práci podařilo.

Dosáhl jsem velmi dobrých výsledků v~oblasti zpracování nových dat do~aktuálních materializovaných pohledů. Průměrné zrychlení činí 93~\%, nejvyšší zrychlení pak více než 99~\%. Předpokládám, že firmě Codasip toto zrychlení
pomůže v~efektivnějším vývoji procesorových jader i~ostatních produktů. Zároveň jsem optimalizoval dotazy, které materializované pohledy aktualizují.

Jako další možnosti rozšíření řešení představeného v~této práci vidím zavedení
\textit{partitions}, které umožní ještě více zrychlit databázové dotazy a~optimalizovat práci s~materializovanými
pohledy. Protože datový model obsahuje často sloupce, jejichž hodnoty mají charakter vhodný k~indexování bitmapovým
indexem, bylo by vhodné detailně prostudovat jiné databázové systémy, který tento druh indexu nabízejí (například
Oracle).
